[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "core/.external-ecmascript.js",
    "static": true,
    "longname": "core/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "core/analyzers/capitalAnalyzer.ts",
    "content": "import {IOrder, OrderSide, OrderStatus} from \"../orderInterface\";\n\nexport interface IAnalyzer {\n    analyze(order: IOrder): void;\n}\n\n/**\n * The CapitalAnalyzer calculates wins ans losses made by using the orders\n * your strategy placed\n */\nexport default class CapitalAnalyzer implements IAnalyzer {\n\n    /**\n     * Creates a new CapitalAnalyzer\n     * @param {number} startCapital your starting capital\n     */\n    constructor(private startCapital: number) {\n        // TODO do something with starting capital\n    }\n\n    /**\n     * Calculates your new capital based on a fulfilled order and compares\n     * it to your old capital\n     * @param {IOrder} order fulfilled order\n     */\n    analyze(order: IOrder) {\n        if (order.status !== OrderStatus.FILLED) {\n            return;\n        }\n\n        const oldCapital = this.startCapital;\n        if (order.side === OrderSide.BUY) {\n            this.startCapital -= (order.price * order.quantity);\n        } else if (order.side === OrderSide.SELL) {\n            this.startCapital += (order.price * order.quantity);\n        }\n\n        console.log(\"capital: \", this.startCapital, \" : \", this.calcPerc(oldCapital, this.startCapital), \"\\n\");\n    }\n\n    /**\n     * Calculates percentage gain or loss\n     * @param {number} a old capital\n     * @param {number} b new capital\n     * @returns {string} percentage gain or loss\n     */\n    calcPerc(a: number, b: number): string {\n        if (b > a) {\n            return `+${(b - a) / a * 100}%`;\n        } else {\n            return `-${(b - a) / b * 100}%`;\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/analyzers/capitalAnalyzer.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CapitalAnalyzer",
    "memberof": "core/analyzers/capitalAnalyzer.ts",
    "static": true,
    "longname": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/analyzers/capitalAnalyzer.ts",
    "importStyle": "CapitalAnalyzer",
    "description": "The CapitalAnalyzer calculates wins ans losses made by using the orders\nyour strategy placed",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer#constructor",
    "access": "public",
    "description": "Creates a new CapitalAnalyzer",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "startCapital",
        "description": "your starting capital"
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "startCapital",
    "memberof": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer",
    "static": false,
    "longname": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer#startCapital",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "method",
    "name": "analyze",
    "memberof": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer#analyze",
    "access": "public",
    "description": "Calculates your new capital based on a fulfilled order and compares\nit to your old capital",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "calcPerc",
    "memberof": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/analyzers/capitalAnalyzer.ts~CapitalAnalyzer#calcPerc",
    "access": "public",
    "description": "Calculates percentage gain or loss",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "core/backTester.ts",
    "content": "import fs from \"fs\";\nimport mkdirp from \"mkdirp\";\nimport {lowercase, numbers, uppercase} from \"nanoid-dictionary\";\nimport generate from \"nanoid/generate\";\nimport path from \"path\";\nimport rimraf from \"rimraf\";\nimport util from \"util\";\nimport {ICandle} from \"./candleCollection\";\nimport CandleLoader, {Parser} from \"./candleLoader\";\nimport localExchange from \"./exchanges/localExchange\";\nimport LocalExchange from \"./exchanges/localExchange\";\nimport {IOrder} from \"./orderInterface\";\nimport SockTrader, {ISockTraderConfig} from \"./sockTrader\";\n\n/**\n * The BackTester enables you to test your strategy against a fake dummy exchange\n * and optimize to the point of content\n */\nexport default class BackTester extends SockTrader {\n\n    private static CACHE_FOLDER = path.resolve(\".sockTrader\");\n    private candleLoader?: CandleLoader;\n\n    /**\n     * Creates a new BackTester\n     * @param {ISockTraderConfig} config\n     */\n    constructor(config: ISockTraderConfig = {webServer: true}) {\n        super(config);\n\n        this.exchange = localExchange.getInstance();\n    }\n\n    /**\n     * Sets the loader responsible for loading local file data into\n     * an in memory candle collection\n     * @param {string} inputPath the path to the file containing candles\n     * @param {Parser} parser the parser for transforming the data\n     * @returns {this}\n     */\n    setCandleLoader(inputPath: string, parser?: Parser): this {\n        this.candleLoader = new CandleLoader(inputPath, parser);\n\n        return this;\n    }\n\n    async start(): Promise<void> {\n        await super.start();\n\n        if (!this.candleLoader) {\n            throw new Error(\"No candle loader defined.\");\n        }\n\n        if (!this.eventsBound) {\n            this.subscribeToExchangeEvents(this.strategyConfigurations);\n\n            this.strategyConfigurations.forEach(c => {\n                const strategy = new c.strategy(c.pair, this.exchange);\n                this.bindStrategyToExchange(strategy);\n                this.bindExchangeToStrategy(strategy);\n                this.bindExchangeToSocketServer();\n            });\n\n            this.eventsBound = true;\n        }\n\n        const candles: ICandle[] = (await this.candleLoader.parse()).toArray();\n        if (this.webServer) {\n            await BackTester.createCache();\n            await BackTester.clearCache();\n            await this.writeCandleCache(candles);\n        }\n\n        await (this.exchange as LocalExchange).emitCandles(candles);\n    }\n\n    private static async clearCache(): Promise<void> {\n        const rmrf = util.promisify(rimraf);\n        await rmrf(`${BackTester.CACHE_FOLDER}/*`);\n    }\n\n    private static async createCache(): Promise<void> {\n        const mkdir = util.promisify(mkdirp);\n        await mkdir(BackTester.CACHE_FOLDER);\n    }\n\n    private bindExchangeToSocketServer() {\n        this.exchange.on(\"app.report\", (order: IOrder) => this.sendToWebServer(\"REPORT\", order));\n    }\n\n    private writeCandleCache(candles: ICandle[]): Promise<string> {\n        return new Promise((resolve, reject) => {\n            const fileName = generate(`${lowercase}${uppercase}${numbers}`, 6);\n            const cacheFile = path.resolve(BackTester.CACHE_FOLDER, `${fileName}.json`);\n\n            const response = JSON.stringify({type: \"CANDLES\", payload: {pair: \"\", candles}});\n            fs.writeFile(cacheFile, response, err => {\n                if (err) return reject(err);\n\n                this.sendToWebServer(\"CANDLE_FILE\", cacheFile);\n                resolve(cacheFile);\n            });\n        });\n\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/backTester.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "class",
    "name": "BackTester",
    "memberof": "core/backTester.ts",
    "static": true,
    "longname": "core/backTester.ts~BackTester",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/backTester.ts",
    "importStyle": "BackTester",
    "description": "The BackTester enables you to test your strategy against a fake dummy exchange\nand optimize to the point of content",
    "lineNumber": 19,
    "interface": false,
    "extends": [
      "core/sockTrader.js~SockTrader"
    ]
  },
  {
    "__docId__": 58,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/backTester.ts~BackTester",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/backTester.ts~BackTester#constructor",
    "access": "public",
    "description": "Creates a new BackTester",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "ISockTraderConfig"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "exchange",
    "memberof": "core/backTester.ts~BackTester",
    "static": false,
    "longname": "core/backTester.ts~BackTester#exchange",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "setCandleLoader",
    "memberof": "core/backTester.ts~BackTester",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/backTester.ts~BackTester#setCandleLoader",
    "access": "public",
    "description": "Sets the loader responsible for loading local file data into\nan in memory candle collection",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inputPath",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Parser"
        ],
        "spread": false,
        "optional": false,
        "name": "parser",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "candleLoader",
    "memberof": "core/backTester.ts~BackTester",
    "static": false,
    "longname": "core/backTester.ts~BackTester#candleLoader",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "start",
    "memberof": "core/backTester.ts~BackTester",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "core/backTester.ts~BackTester#start",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "eventsBound",
    "memberof": "core/backTester.ts~BackTester",
    "static": false,
    "longname": "core/backTester.ts~BackTester#eventsBound",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "clearCache",
    "memberof": "core/backTester.ts~BackTester",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "core/backTester.ts~BackTester.clearCache",
    "access": "public",
    "description": "",
    "lineNumber": 77,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "createCache",
    "memberof": "core/backTester.ts~BackTester",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "core/backTester.ts~BackTester.createCache",
    "access": "public",
    "description": "",
    "lineNumber": 82,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "bindExchangeToSocketServer",
    "memberof": "core/backTester.ts~BackTester",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/backTester.ts~BackTester#bindExchangeToSocketServer",
    "access": "public",
    "description": "",
    "lineNumber": 87,
    "params": [],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "writeCandleCache",
    "memberof": "core/backTester.ts~BackTester",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/backTester.ts~BackTester#writeCandleCache",
    "access": "public",
    "description": "",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "core/candleCollection.ts",
    "content": "import {CronJob} from \"cron\";\nimport parser from \"cron-parser\";\nimport {EventEmitter} from \"events\";\nimport moment, {Moment} from \"moment\";\nimport config from \"../config\";\nimport logger from \"./logger\";\n\nexport interface ICandle {\n    close: number;\n    high: number;\n    low: number;\n    open: number;\n    timestamp: Moment;\n    volume: number;\n}\n\nexport interface ICandleInterval {\n    code: string;\n    cron: string;\n}\n\nexport interface IIntervalDict {\n    [key: string]: ICandleInterval;\n}\n\n/**\n * Contains OHLCV history data for a trading pair.\n * The collection will automatically fill holes when initial and new data is pushed\n * The collection can automatically generate values if no new values were pushed during a time interval\n */\nexport default class CandleCollection extends EventEmitter {\n    private candles: ICandle[] = [];\n    private cronjob: CronJob;\n\n    /**\n     * Creates a new CandleCollection\n     * @param {ICandleInterval} interval the interval between the candles\n     * @param {boolean} generateCandles if should generate candles when nothing is received\n     * @param {number} retentionPeriod how long to keep candles\n     */\n    constructor(private interval: ICandleInterval, generateCandles = true, private retentionPeriod = 0) {\n        super();\n\n        const candleGenerator = this.generateCandles.bind(this);\n        this.cronjob = new CronJob(interval.cron, candleGenerator, undefined, generateCandles, config.timezone);\n    }\n\n    /**\n     * Immediately set/replace all candles in the collection\n     */\n    set(candles: ICandle[]): void {\n        const interval = parser.parseExpression(this.interval.cron, {\n            endDate: candles[0].timestamp.toDate(),\n            currentDate: new Date(),\n        });\n\n        this.candles = this.fillCandleGaps(candles, interval).reverse();\n        this.emit(\"update\", this.candles);\n    }\n\n    sort = (candles: ICandle[]): ICandle[] => candles.sort((a, b) => b.timestamp.diff(a.timestamp));\n\n    /**\n     * Stop automatic candle generator\n     */\n    stop() {\n        this.cronjob.stop();\n    }\n\n    /**\n     * Update or insert newly received candles\n     * @param {ICandle[]} candles candles to add\n     */\n    update(candles: ICandle[]): void {\n        let needsSort = false;\n        candles.forEach(updatedCandle => {\n            const candleUpdated = this.candles.some((candle, idx) => {\n                if (this.candleEqualsTimestamp(candle, updatedCandle.timestamp)) {\n                    this.candles[idx] = updatedCandle;\n                    return true;\n                }\n                return false;\n            });\n\n            if (!candleUpdated) {\n                const l = this.candles.unshift(updatedCandle);\n                this.removeRetentionOverflow(this.candles);\n\n                // You need at least 2 candles to sort the list..\n                if (l >= 2 && !this.candles[0].timestamp.isAfter(this.candles[1].timestamp, \"minute\")) {\n                    logger.error(`Server has changed candle history! Suspected candle: ${JSON.stringify(updatedCandle)}`);\n                    needsSort = true;\n                }\n            }\n        });\n\n        if (needsSort) {\n            this.candles = this.sort(this.candles);\n        }\n\n        this.emit(\"update\", this.candles);\n    }\n\n    /**\n     * Validates if a candle occurs on a certain timestamp\n     * @param {ICandle} candle the candle\n     * @param {moment.Moment} timestamp the time\n     * @returns {boolean} occurs on given time\n     */\n    private candleEqualsTimestamp(candle: ICandle, timestamp: Moment): boolean {\n        return candle.timestamp.isSameOrAfter(timestamp, \"minute\");\n    }\n\n    /**\n     * Fill gaps in candle list until now, based on a cron expression\n     * @param {ICandle[]} candles candle collection to fill\n     * @param interval interval for which to fill\n     * @returns {ICandle[]} the filled collection\n     */\n    private fillCandleGaps(candles: ICandle[], interval: any): ICandle[] {\n        candles = this.sort(candles);\n\n        const result: ICandle[] = [];\n        const generateCandle = this.getCandleGenerator(candles);\n\n        while (true) {\n            const nextInterval: Moment = moment(interval.prev().toDate());\n            const candle = generateCandle(nextInterval);\n\n            result.unshift(candle);\n\n            if (result.length === this.retentionPeriod) break;\n\n            if (this.candleEqualsTimestamp(candles[candles.length - 1], nextInterval)) break;\n        }\n\n        return result;\n    }\n\n    /**\n     * Generate new candles on each candle interval\n     */\n    private generateCandles(): void {\n        const last = moment(this.cronjob.lastDate()).second(0).millisecond(0);\n\n        if (this.candles.length <= 0) {\n            this.candles.unshift(this.getRecycledCandle({close: 0} as ICandle, last));\n        } else if (last.isAfter(this.candles[0].timestamp, \"minute\")) {\n            this.candles.unshift(this.getRecycledCandle(this.candles[0], last));\n        }\n\n        this.removeRetentionOverflow(this.candles);\n        this.emit(\"update\", this.candles);\n    }\n\n    /**\n     * Returns a function which will either return a new candle or recycle a previous candle\n     * This function should be executed on every timer tick so that even though no values\n     * changed, the candle collection receives a 'new' candle\n     * @param {ICandle[]} candle collection\n     * @returns {(interval: moment.Moment) => ICandle} candle generator\n     */\n    private getCandleGenerator(candles: ICandle[]): (interval: Moment) => ICandle {\n        let position = 0;\n        return nextInterval => {\n            let candle = candles[position];\n\n            if (!this.candleEqualsTimestamp(candle, nextInterval)) {\n                candle = this.getRecycledCandle(candles[position], nextInterval);\n            } else {\n                position += 1;\n            }\n\n            return candle;\n        };\n    }\n\n    /**\n     * Copy candle based on the close value of a different candle\n     * for indicating an interval without price change\n     * @param {number} close the close\n     * @param {moment.Moment} timestamp the timestamp\n     * @returns {ICandle} copied candle\n     */\n    private getRecycledCandle = ({close}: ICandle, timestamp: Moment): ICandle => ({\n        open: close,\n        high: close,\n        low: close,\n        close,\n        volume: 0,\n        timestamp,\n    })\n\n    /**\n     * Removes candles outside the retention period\n     * @param {ICandle[]} candles the candle collection\n     */\n    private removeRetentionOverflow(candles: ICandle[]): void {\n        if (this.retentionPeriod > 0 && candles.length > this.retentionPeriod) {\n            candles.splice(this.retentionPeriod - candles.length);\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/candleCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "CandleCollection",
    "memberof": "core/candleCollection.ts",
    "static": true,
    "longname": "core/candleCollection.ts~CandleCollection",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/candleCollection.ts",
    "importStyle": "CandleCollection",
    "description": "Contains OHLCV history data for a trading pair.\nThe collection will automatically fill holes when initial and new data is pushed\nThe collection can automatically generate values if no new values were pushed during a time interval",
    "lineNumber": 31,
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#constructor",
    "access": "public",
    "description": "Creates a new CandleCollection",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "ICandleInterval"
        ],
        "spread": false,
        "optional": false,
        "name": "interval",
        "description": "the interval between the candles"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "generateCandles",
        "description": "if should generate candles when nothing is received"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "retentionPeriod",
        "description": "how long to keep candles"
      }
    ]
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "interval",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#interval",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "retentionPeriod",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#retentionPeriod",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "candles",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#candles",
    "access": "public",
    "description": "",
    "lineNumber": 32,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "sort",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#sort",
    "access": "public",
    "description": "",
    "lineNumber": 61,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "getRecycledCandle",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#getRecycledCandle",
    "access": "public",
    "description": "Copy candle based on the close value of a different candle\nfor indicating an interval without price change",
    "lineNumber": 185,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "cronjob",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#cronjob",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "set",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#set",
    "access": "public",
    "description": "Immediately set/replace all candles in the collection",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "stop",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#stop",
    "access": "public",
    "description": "Stop automatic candle generator",
    "lineNumber": 66,
    "params": [],
    "return": null
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "update",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#update",
    "access": "public",
    "description": "Update or insert newly received candles",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "candleEqualsTimestamp",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#candleEqualsTimestamp",
    "access": "public",
    "description": "Validates if a candle occurs on a certain timestamp",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "ICandle"
        ],
        "spread": false,
        "optional": false,
        "name": "candle",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Moment"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "fillCandleGaps",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#fillCandleGaps",
    "access": "public",
    "description": "Fill gaps in candle list until now, based on a cron expression",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "interval",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "generateCandles",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#generateCandles",
    "access": "public",
    "description": "Generate new candles on each candle interval",
    "lineNumber": 143,
    "params": [],
    "return": null
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "getCandleGenerator",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#getCandleGenerator",
    "access": "public",
    "description": "Returns a function which will either return a new candle or recycle a previous candle\nThis function should be executed on every timer tick so that even though no values\nchanged, the candle collection receives a 'new' candle",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "removeRetentionOverflow",
    "memberof": "core/candleCollection.ts~CandleCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleCollection.ts~CandleCollection#removeRetentionOverflow",
    "access": "public",
    "description": "Removes candles outside the retention period",
    "lineNumber": 198,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 87,
    "kind": "file",
    "name": "core/candleLoader.ts",
    "content": "import {IDataFrame} from \"data-forge\";\nimport {IAsyncFileReader, readFile} from \"data-forge-fs\";\n\nexport type Parser = (candles: IDataFrame<number, any>) => IDataFrame<number, any>;\n\n/**\n * The CandleLoader parses a file containing candles and returns\n * in data for in memory processing\n */\nexport default class CandleLoader {\n\n    constructor(private filePath: string, private parser?: Parser) {\n    }\n\n    /**\n     * Parses file depending on the extension/type\n     * @param {IAsyncFileReader} fileReader the file to read\n     * @param {string} extension the extension\n     * @returns {Promise<IDataFrame<number, any>>} promise\n     */\n    static async parseFileReader(fileReader: IAsyncFileReader, extension: string): Promise<IDataFrame<number, any>> {\n        if (extension === \"json\") {\n            return await fileReader.parseJSON();\n        }\n\n        if (extension === \"csv\") {\n            return await fileReader.parseCSV({dynamicTyping: true});\n        }\n\n        throw new Error(\"File extension is not valid! Expecting a CSV or JSON file.\");\n    }\n\n    /**\n     * Actual parsing of file returning data\n     * @returns {Promise<IDataFrame<number, any>>}\n     */\n    async parse(): Promise<IDataFrame<number, any>> {\n        const segs = this.filePath.split(\".\");\n        const ext = segs[segs.length - 1].toLowerCase();\n\n        const dataFrame = await CandleLoader.parseFileReader(readFile(this.filePath), ext);\n        return (this.parser) ? this.parser(dataFrame) : dataFrame;\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/candleLoader.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 88,
    "kind": "class",
    "name": "CandleLoader",
    "memberof": "core/candleLoader.ts",
    "static": true,
    "longname": "core/candleLoader.ts~CandleLoader",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/candleLoader.ts",
    "importStyle": "CandleLoader",
    "description": "The CandleLoader parses a file containing candles and returns\nin data for in memory processing",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 89,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/candleLoader.ts~CandleLoader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/candleLoader.ts~CandleLoader#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "filePath",
    "memberof": "core/candleLoader.ts~CandleLoader",
    "static": false,
    "longname": "core/candleLoader.ts~CandleLoader#filePath",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "parser",
    "memberof": "core/candleLoader.ts~CandleLoader",
    "static": false,
    "longname": "core/candleLoader.ts~CandleLoader#parser",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "parseFileReader",
    "memberof": "core/candleLoader.ts~CandleLoader",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "core/candleLoader.ts~CandleLoader.parseFileReader",
    "access": "public",
    "description": "Parses file depending on the extension/type",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAsyncFileReader"
        ],
        "spread": false,
        "optional": false,
        "name": "fileReader",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "extension",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "parse",
    "memberof": "core/candleLoader.ts~CandleLoader",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "core/candleLoader.ts~CandleLoader#parse",
    "access": "public",
    "description": "Actual parsing of file returning data",
    "lineNumber": 37,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "core/exchanges/baseExchange.ts",
    "content": "import {Decimal} from \"decimal.js-light\";\nimport {EventEmitter} from \"events\";\nimport {lowercase, numbers, uppercase} from \"nanoid-dictionary\";\nimport generate from \"nanoid/generate\";\nimport {Error} from \"tslint/lib/error\";\nimport {client as WebSocketClient, connection, IMessage} from \"websocket\";\nimport CandleCollection, {ICandle, ICandleInterval} from \"../candleCollection\";\nimport logger from \"../logger\";\nimport Orderbook, {IOrderbookEntry} from \"../orderbook\";\nimport {IOrder, OrderSide, OrderStatus, ReportType} from \"../orderInterface\";\nimport {Pair} from \"../types/pair\";\nimport {IExchange} from \"./exchangeInterface\";\n\nexport interface IResponseMapper {\n    onReceive(msg: IMessage): void;\n}\n\nexport interface ICurrencyMap {\n    [key: string]: ITradeablePair;\n}\n\nexport interface ITradeablePair {\n    id: Pair;\n    quantityIncrement: number;\n    tickSize: number;\n}\n\nexport interface IOrderbookData {\n    ask: IOrderbookEntry[];\n    bid: IOrderbookEntry[];\n    pair: Pair;\n    sequence: number;\n}\n\n/**\n * The BaseExchange resembles common marketplace functionality\n */\nexport default abstract class BaseExchange extends EventEmitter implements IExchange {\n    currencies: ICurrencyMap = {};\n    isAuthenticated = false;\n    isCurrenciesLoaded = false;\n    protected candles: { [key: string]: CandleCollection } = {};\n    protected openOrders: IOrder[] = [];\n    protected socketClient: WebSocketClient = new WebSocketClient();\n    private connection?: connection;\n    private orderbooks: { [key: string]: Orderbook } = {};\n    private orderIncrement = 0;\n    private orderInProgress: { [key: string]: boolean } = {};\n    private ready = false;\n\n    protected constructor() {\n        super();\n\n        this.onCreate();\n    }\n\n    abstract adjustOrder(order: IOrder, price: number, qty: number): void;\n\n    buy(pair: Pair, price: number, qty: number): void {\n        this.createOrder(pair, price, qty, OrderSide.BUY);\n    }\n\n    abstract cancelOrder(order: IOrder): void;\n\n    connect(connectionString: string): void {\n        this.socketClient.on(\"connectFailed\", error => logger.error(\"Connect Error: \" + error.toString()));\n        this.socketClient.on(\"connect\", (conn: connection) => this.onConnect(conn));\n\n        this.socketClient.connect(connectionString);\n    }\n\n    abstract createOrder(pair: Pair, price: number, qty: number, side: OrderSide): void;\n\n    destroy(): void {\n        this.removeAllListeners();\n    }\n\n    /**\n     * Wraps the emit and notifies if no listeners where found\n     * @param {string | symbol} event to throw\n     * @param args event arguments\n     * @returns {boolean} if listeners where found\n     */\n    emit(event: string | symbol, ...args: any[]): boolean {\n        const result = super.emit(event, ...args);\n        // TODO create config for all debug statements only to be active in dev\n        if (!result && process.env.NODE_ENV === \"dev\") {\n            logger.debug(`No listener found for: \"${event.toString()}\"`);\n        }\n\n        return result;\n    }\n\n    /**\n     * Generates orderId based on trading pair, timestamp, increment and random string. With max length 32 characters\n     * ex: 15COVETH1531299734778DkXBry9y-sQ\n     * @param pair crypto pair (BTC USD/BTC ETH)\n     * @returns {string} order id\n     */\n    generateOrderId(pair: Pair): string {\n        this.orderIncrement += 1;\n\n        const alphabet = `${lowercase}${uppercase}${numbers}_-.|`;\n        const orderId = `${this.orderIncrement}${pair}${new Date().getTime()}`;\n\n        return orderId + generate(alphabet, 32 - orderId.length);\n    }\n\n    /**\n     * Returns candle collection for pair and interval\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {ICandleInterval} interval time interval\n     * @param {(candles: CandleCollection) => void} updateHandler what to do if candle collection updates\n     * @returns {CandleCollection} the candle collection\n     */\n    getCandleCollection(pair: Pair, interval: ICandleInterval, updateHandler: (candles: CandleCollection) => void): CandleCollection {\n        const key = `${pair}_${interval.code}`;\n        if (this.candles[key]) {\n            return this.candles[key];\n        }\n\n        this.candles[key] = new CandleCollection(interval);\n        this.candles[key].on(\"update\", updateHandler);\n        return this.candles[key];\n    }\n\n    getOpenOrders = (): IOrder[] => this.openOrders;\n\n    getOrderbook(pair: Pair): Orderbook {\n        const ticker = pair.join(\"\");\n        if (this.orderbooks[ticker]) {\n            return this.orderbooks[ticker];\n        }\n\n        const config = this.currencies[ticker];\n        if (!config) {\n            throw new Error(`No configuration found for pair: \"${ticker}\"`);\n        }\n\n        const precision = new Decimal(config.tickSize).decimalPlaces();\n\n        this.orderbooks[ticker] = new Orderbook(pair, precision);\n        return this.orderbooks[ticker];\n    }\n\n    /**\n     * Verify if the exchange is ready and trigger the \"ready\" event if ready.\n     * Can be called multiple times.. it will trigger the \"ready\" event only once.\n     * @returns {boolean}\n     */\n    isReady(): boolean {\n        if (this.ready) {\n            return this.ready;\n        }\n\n        if (this.isCurrenciesLoaded && this.isAuthenticated) {\n            this.ready = true;\n            this.emit(\"ready\");\n        }\n\n        return this.ready;\n    }\n\n    /**\n     * Wrapper for the on method to log registration of listeners\n     * @param {string} event the event to register to\n     * @param {(...args: any[]) => void} listener the listeners to bind\n     * @returns {this} exchange\n     */\n    on(event: string, listener: (...args: any[]) => void): this {\n        // TODO create config for all debug statements only to be active in dev\n        if (process.env.NODE_ENV === \"dev\") {\n            logger.debug(`Listener created for: \"${event.toString()}\"`);\n        }\n        return super.on(event, listener);\n    }\n\n    onCreate(): void {\n        setInterval(() => {\n            this.orderIncrement = 0;\n        }, 1000 * 60 * 5); // Reset increment every 5 minutes\n    }\n\n    onCurrenciesLoaded(currencies: ITradeablePair[]): void {\n        currencies.forEach(currency => this.currencies[currency.id.join(\"\")] = currency);\n        this.isCurrenciesLoaded = true;\n        this.isReady();\n    }\n\n    onReport(order: IOrder): void {\n        const orderId = order.id;\n        let oldOrder: IOrder | undefined;\n\n        this.setOrderInProgress(orderId, false);\n\n        if (order.reportType === ReportType.REPLACED && order.originalId) {\n            const oldOrderId = order.originalId;\n\n            oldOrder = this.openOrders.find(oo => oo.id === oldOrderId);\n            this.setOrderInProgress(oldOrderId, false);\n            this.removeOrder(oldOrderId);\n            this.addOrder(order); // Order is replaced with a new one\n        } else if (order.reportType === ReportType.NEW) {\n            this.addOrder(order); // New order created\n        } else if (order.reportType === ReportType.TRADE && order.status === OrderStatus.FILLED) {\n            this.removeOrder(orderId); // Order is 100% filled\n        } else if ([ReportType.CANCELED, ReportType.EXPIRED, ReportType.SUSPENDED].indexOf(order.reportType) > -1) {\n            this.removeOrder(orderId); // Order is invalid\n        }\n\n        this.emit(\"app.report\", order, oldOrder);\n    }\n\n    abstract onUpdateCandles<K extends keyof CandleCollection>(pair: Pair, data: ICandle[], interval: ICandleInterval, method: Extract<K, \"set\" | \"update\">): void;\n\n    abstract onUpdateOrderbook<K extends keyof Orderbook>(data: IOrderbookData, method: Extract<K, \"setOrders\" | \"addIncrement\">): void;\n\n    sell(pair: Pair, price: number, qty: number): void {\n        this.createOrder(pair, price, qty, OrderSide.SELL);\n    }\n\n    /**\n     * Send request over socket connection\n     * @param {string} method the type of send\n     * @param {object} params the data\n     */\n    send(method: string, params: object = {}): void {\n        const command = {method, params, id: method};\n        if (this.connection === undefined) {\n            throw new Error(\"First connect to the exchange before sending instructions..\");\n        }\n\n        this.connection.send(JSON.stringify(command));\n    }\n\n    abstract subscribeCandles(pair: Pair, interval: ICandleInterval): void;\n\n    abstract subscribeOrderbook(pair: Pair): void;\n\n    /**\n     * Listen for actions that are happening on the remote exchange\n     */\n    abstract subscribeReports(): void;\n\n    /**\n     * Adds order to local array\n     * @param {IOrder} order the order to add\n     */\n    protected addOrder(order: IOrder): void {\n        this.openOrders.push(order);\n    }\n\n    /**\n     * Validates if adjusting an existing order on an exchange is allowed\n     * @param order the order to check\n     * @param price new price\n     * @param qty new quantity\n     */\n    protected isAdjustingOrderAllowed(order: IOrder, price: number, qty: number): boolean {\n        if (this.orderInProgress[order.id]) {\n            return false; // Order still in progress\n        }\n\n        if (order.price === price && order.quantity === qty) {\n            return false; // Old order === new order. No need to replace!\n        }\n\n        this.setOrderInProgress(order.id);\n        return true;\n    }\n\n    /**\n     * Load trading pair configuration\n     */\n    protected abstract loadCurrencies(): void;\n\n    /**\n     * Triggers when the exchange is connected to the websocket API\n     * @param {connection} conn the connection\n     */\n    protected onConnect(conn: connection): void {\n        this.connection = conn;\n        this.connection.on(\"error\", error => logger.error(\"Connection Error: \" + error.toString()));\n        this.connection.on(\"close\", () => logger.info(\"Connection Closed\"));\n    }\n\n    /**\n     * Remove order from local array\n     * @param {string} orderId of the order to remove\n     */\n    protected removeOrder(orderId: string): void {\n        this.openOrders = this.openOrders.filter(o => o.id !== orderId);\n    }\n\n    /**\n     * Sets the order in progress\n     * @param {string} orderId of the order to set in progress\n     * @param {boolean} state whether the order still has state\n     */\n    protected setOrderInProgress(orderId: string, state = true): void {\n        if (state === false) {\n            delete this.orderInProgress[orderId];\n        } else {\n            this.orderInProgress[orderId] = state;\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/exchanges/baseExchange.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "class",
    "name": "BaseExchange",
    "memberof": "core/exchanges/baseExchange.ts",
    "static": true,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/exchanges/baseExchange.ts",
    "importStyle": "BaseExchange",
    "description": "The BaseExchange resembles common marketplace functionality",
    "lineNumber": 38,
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 96,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "currencies",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#currencies",
    "access": "public",
    "description": "",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "ICurrencyMap"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "isAuthenticated",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#isAuthenticated",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "isCurrenciesLoaded",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#isCurrenciesLoaded",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "candles",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#candles",
    "access": "public",
    "description": "",
    "lineNumber": 42,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "openOrders",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#openOrders",
    "access": "public",
    "description": "",
    "lineNumber": 43,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "socketClient",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#socketClient",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "WebSocketClient"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "orderbooks",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#orderbooks",
    "access": "public",
    "description": "",
    "lineNumber": 46,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "orderIncrement",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#orderIncrement",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "orderInProgress",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#orderInProgress",
    "access": "public",
    "description": "",
    "lineNumber": 48,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "ready",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#ready",
    "access": "public",
    "description": "",
    "lineNumber": 49,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "getOpenOrders",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#getOpenOrders",
    "access": "public",
    "description": "",
    "lineNumber": 127,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "buy",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#buy",
    "access": "public",
    "description": "",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "connect",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#connect",
    "access": "public",
    "description": "",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "connectionString",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "destroy",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#destroy",
    "access": "public",
    "description": "",
    "lineNumber": 74,
    "params": [],
    "return": null
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "emit",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#emit",
    "access": "public",
    "description": "Wraps the emit and notifies if no listeners where found",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "generateOrderId",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#generateOrderId",
    "access": "public",
    "description": "Generates orderId based on trading pair, timestamp, increment and random string. With max length 32 characters\nex: 15COVETH1531299734778DkXBry9y-sQ",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "getCandleCollection",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#getCandleCollection",
    "access": "public",
    "description": "Returns candle collection for pair and interval",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ICandleInterval"
        ],
        "spread": false,
        "optional": false,
        "name": "interval",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "updateHandler",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CandleCollection"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "getOrderbook",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#getOrderbook",
    "access": "public",
    "description": "",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Orderbook"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "isReady",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#isReady",
    "access": "public",
    "description": "Verify if the exchange is ready and trigger the \"ready\" event if ready.\nCan be called multiple times.. it will trigger the \"ready\" event only once.",
    "lineNumber": 151,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "on",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#on",
    "access": "public",
    "description": "Wrapper for the on method to log registration of listeners",
    "lineNumber": 170,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "listener",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "onCreate",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#onCreate",
    "access": "public",
    "description": "",
    "lineNumber": 178,
    "params": [],
    "return": null
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "onCurrenciesLoaded",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#onCurrenciesLoaded",
    "access": "public",
    "description": "",
    "lineNumber": 184,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "currencies",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "onReport",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#onReport",
    "access": "public",
    "description": "",
    "lineNumber": 190,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "sell",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#sell",
    "access": "public",
    "description": "",
    "lineNumber": 218,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "send",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#send",
    "access": "public",
    "description": "Send request over socket connection",
    "lineNumber": 227,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "addOrder",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#addOrder",
    "access": "public",
    "description": "Adds order to local array",
    "lineNumber": 249,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "isAdjustingOrderAllowed",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#isAdjustingOrderAllowed",
    "access": "public",
    "description": "Validates if adjusting an existing order on an exchange is allowed",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "onConnect",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#onConnect",
    "access": "public",
    "description": "Triggers when the exchange is connected to the websocket API",
    "lineNumber": 281,
    "params": [
      {
        "nullable": null,
        "types": [
          "connection"
        ],
        "spread": false,
        "optional": false,
        "name": "conn",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "connection",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#connection",
    "access": "public",
    "description": null,
    "lineNumber": 389,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "removeOrder",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#removeOrder",
    "access": "public",
    "description": "Remove order from local array",
    "lineNumber": 291,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "orderId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "setOrderInProgress",
    "memberof": "core/exchanges/baseExchange.ts~BaseExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/baseExchange.ts~BaseExchange#setOrderInProgress",
    "access": "public",
    "description": "Sets the order in progress",
    "lineNumber": 300,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "orderId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "state",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 133,
    "kind": "file",
    "name": "core/exchanges/exchangeInterface.ts",
    "content": "import {EventEmitter} from \"events\";\nimport CandleCollection, {ICandle, ICandleInterval} from \"../candleCollection\";\nimport Orderbook from \"../orderbook\";\nimport {IOrder, OrderSide} from \"../orderInterface\";\nimport {Pair} from \"../types/pair\";\nimport {IOrderbookData, ITradeablePair} from \"./baseExchange\";\n\n/**\n * The IExchange represents a marketplace to buy and sell\n * cryptocurrencies\n */\nexport interface IExchange extends EventEmitter {\n\n    isAuthenticated: boolean;\n    isCurrenciesLoaded: boolean;\n\n    /**\n     * Adjusts existing order on exchange\n     * @param order the order to adjust\n     * @param price the new price\n     * @param qty the new quantity\n     */\n    adjustOrder(order: IOrder, price: number, qty: number): void;\n\n    /**\n     * Signals a buy to the exchange\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {number} price at which to buy/sell\n     * @param {number} qty quantity to buy/sell\n     */\n    buy(pair: Pair, price: number, qty: number): void;\n\n    /**\n     * Cancel existing order on exchange\n     * @param {IOrder} order to cancel\n     */\n    cancelOrder(order: IOrder): void;\n\n    /**\n     * Connects to the exchange with given connection properties\n     * @param {string} connectionString web socket url to connect to\n     */\n    connect(connectionString?: string): void;\n\n    /**\n     * Places an order on the exchange\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {number} price at which to buy/sell\n     * @param {number} qty quantity to buy/sell\n     * @param {OrderSide} side buy or sell\n     * @returns {string} order id\n     */\n    createOrder(pair: Pair, price: number, qty: number, side: OrderSide): void;\n\n    /**\n     * Removes the exchanges from the running application\n     * i.e. removes the event listeners\n     */\n    destroy(): void;\n\n    /**\n     * Gets all orders that have not yet been filled\n     * @returns {IOrder[]}\n     */\n    getOpenOrders(): IOrder[];\n\n    /**\n     * Gets all (of everyone) open buy and sell order for a given pair on the\n     * exchange\n     * @param pair crypto pair (BTC USD/BTC ETH)\n     * @returns {Orderbook} open buys and sells for pair\n     */\n    getOrderbook(pair: Pair): Orderbook;\n\n    /**\n     * Fires when exchange is created\n     */\n    onCreate(): void;\n\n    /**\n     * Registers all tradeable currencies on exchange\n     * @param {ITradeablePair[]} currencies\n     */\n    onCurrenciesLoaded(currencies: ITradeablePair[]): void;\n\n    /**\n     * Updates the local order when exchange sends updated information\n     * @param {IOrder} order the order to update\n     */\n    onReport(order: IOrder): void;\n\n    /**\n     * Updates local candle collection with collection from exchange\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {ICandle[]} candles updated candles\n     * @param {ICandleInterval} interval candle interval\n     * @param {Extract<K extends keyof CandleCollection, \"set\" | \"update\">} method whether to update or overwrite\n     */\n    onUpdateCandles<K extends keyof CandleCollection>(pair: Pair, candles: ICandle[], interval: ICandleInterval, method: Extract<K, \"set\" | \"update\">): void;\n\n    /**\n     * Updates local order collection with collection from exchange\n     * @param {IOrderbookData} orderBook the orders\n     * @param {Extract<K extends keyof Orderbook, \"setOrders\" | \"addIncrement\">} method whether to update or overwrite\n     */\n    onUpdateOrderbook<K extends keyof Orderbook>(orderBook: IOrderbookData, method: Extract<K, \"setOrders\" | \"addIncrement\">): void;\n\n    /**\n     * Sends a sell signal to the exchange\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {number} price at which to sell\n     * @param {number} qty to buy\n     */\n    sell(pair: Pair, price: number, qty: number): void;\n\n    /**\n     * Registers to a candle collection for a given pair/interval\n     * e.g. BTC/ETH every 5 minutes\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {ICandleInterval} interval time interval\n     */\n    subscribeCandles(pair: Pair, interval: ICandleInterval): void;\n\n    /**\n     * Registers to order book for given pair\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     */\n    subscribeOrderbook(pair: Pair): void;\n\n    /**\n     * Registers to order updates\n     */\n    subscribeReports(): void;\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/exchanges/exchangeInterface.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 134,
    "kind": "file",
    "name": "core/exchanges/hitBTC.ts",
    "content": "import crypto from \"crypto\";\nimport nanoid from \"nanoid\";\nimport {connection, IMessage} from \"websocket\";\nimport CandleCollection, {ICandle, ICandleInterval, IIntervalDict} from \"../candleCollection\";\nimport logger from \"../logger\";\nimport Orderbook from \"../orderbook\";\nimport {IOrder, OrderSide} from \"../orderInterface\";\nimport {Pair} from \"../types/pair\";\nimport BaseExchange, {IOrderbookData, IResponseMapper} from \"./baseExchange\";\nimport HitBTCMapper from \"./hitBTCMapper\";\n\nexport const CandleInterval: IIntervalDict = {\n    ONE_MINUTE: {code: \"M1\", cron: \"00 */1 * * * *\"},\n    THREE_MINUTES: {code: \"M3\", cron: \"00 */3 * * * *\"},\n    FIVE_MINUTES: {code: \"M5\", cron: \"00 */5 * * * *\"},\n    FIFTEEN_MINUTES: {code: \"M15\", cron: \"00 */15 * * * *\"},\n    THIRTY_MINUTES: {code: \"M30\", cron: \"00 */30 * * * *\"},\n    ONE_HOUR: {code: \"H1\", cron: \"00 00 */1 * * *\"},\n    FOUR_HOURS: {code: \"H4\", cron: \"00 00 2,6,10,14,18,22 * * *\"},\n    ONE_DAY: {code: \"D1\", cron: \"00 00 00 */1 * *\"},\n    SEVEN_DAYS: {code: \"D7\", cron: \"00 00 00 */7 * *\"},\n    ONE_MONTH: {code: \"1M\", cron: \"00 00 00 00 */1 *\"},\n};\n\n/**\n * The HitBTC class represent the HitBTC exchange\n * @see https://hitbtc.com/\n */\nexport default class HitBTC extends BaseExchange {\n\n    readonly mapper: IResponseMapper = new HitBTCMapper(this);\n    private static instance?: HitBTC;\n    private sequence = 0;\n\n    /**\n     * Creates a new HitBTC exchange\n     * @param {string} pubKey the public key for connecting\n     * @param {string} secKey the secret key for connecting\n     */\n    constructor(private pubKey = \"\", private secKey = \"\") {\n        super();\n    }\n\n    /**\n     * Creates a singleton instance of HitBTC\n     * @param {string} pKey public key\n     * @param {string} sKey secret key\n     * @returns {HitBTC} HitBTC instance\n     */\n    static getInstance(pKey = \"\", sKey = \"\") {\n        if (!HitBTC.instance) {\n            HitBTC.instance = new HitBTC(pKey, sKey);\n        }\n        return HitBTC.instance;\n    }\n\n    adjustOrder(order: IOrder, price: number, qty: number): void {\n        if (this.isAdjustingOrderAllowed(order, price, qty)) {\n            const newOrderId = this.generateOrderId(order.pair);\n\n            this.send(\"cancelReplaceOrder\", {\n                clientOrderId: order.id,\n                price,\n                quantity: qty,\n                requestClientId: newOrderId,\n                strictValidate: true,\n            });\n        }\n    }\n\n    cancelOrder(order: IOrder): void {\n        this.setOrderInProgress(order.id);\n        this.send(\"cancelOrder\", {clientOrderId: order.id});\n    }\n\n    connect() {\n        super.connect(\"wss://api.hitbtc.com/api/2/ws\");\n    }\n\n    createOrder(pair: Pair, price: number, qty: number, side: OrderSide): void {\n        const orderId = this.generateOrderId(pair);\n        this.setOrderInProgress(orderId);\n\n        logger.info(`${side.toUpperCase()} ORDER! PRICE: ${price} SIZE: ${qty}`);\n        this.send(\"newOrder\", {\n            clientOrderId: orderId,\n            price,\n            quantity: qty,\n            side,\n            symbol: pair,\n            type: \"limit\",\n        });\n    }\n\n    loadCurrencies(): void {\n        this.send(\"getSymbols\");\n    }\n\n    /**\n     * Authenticates user on exchange using secure signed nonce\n     * @param publicKey the public key\n     * @param privateKey the private key\n     */\n    login(publicKey: string, privateKey: string): void {\n        const nonce: string = nanoid(32);\n        const signature: string = crypto.createHmac(\"sha256\", privateKey).update(nonce).digest(\"hex\");\n\n        this.send(\"login\", {\n            algo: \"HS256\",\n            nonce,\n            pKey: publicKey,\n            signature,\n        });\n    }\n\n    onUpdateCandles<K extends keyof CandleCollection>(pair: Pair, data: ICandle[], interval: ICandleInterval, method: Extract<K, \"set\" | \"update\">): void {\n        const candleCollection = this.getCandleCollection(pair, interval, candles => this.emit(\"app.updateCandles\", candles));\n        return candleCollection[method](data);\n    }\n\n    onUpdateOrderbook<K extends keyof Orderbook>(response: IOrderbookData, method: Extract<K, \"setOrders\" | \"addIncrement\">): void {\n        if (response.sequence <= this.sequence) {\n            logger.info(`Sequence dropped: ${response.sequence}, last one: ${this.sequence}`);\n            return;\n        }\n\n        this.sequence = response.sequence;\n        const orderbook: Orderbook = this.getOrderbook(response.pair);\n        orderbook[method](response.ask, response.bid);\n\n        this.emit(\"app.updateOrderbook\", orderbook);\n    }\n\n    subscribeCandles = (pair: Pair, interval: ICandleInterval): void => this.send(\"subscribeCandles\", {\n        symbol: pair,\n        period: interval.code,\n    })\n\n    subscribeOrderbook = (pair: Pair): void => this.send(\"subscribeOrderbook\", {symbol: pair});\n\n    subscribeReports = (): void => this.send(\"subscribeReports\");\n\n    protected onConnect(conn: connection): void {\n        super.onConnect(conn);\n\n        conn.on(\"message\", (data: IMessage) => this.mapper.onReceive(data));\n\n        this.loadCurrencies();\n\n        if (this.pubKey !== \"\" && this.secKey !== \"\") {\n            logger.info(\"Live credentials are used!\");\n            this.login(this.pubKey, this.secKey);\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/exchanges/hitBTC.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "CandleInterval",
    "memberof": "core/exchanges/hitBTC.ts",
    "static": true,
    "longname": "core/exchanges/hitBTC.ts~CandleInterval",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/exchanges/hitBTC.ts",
    "importStyle": "{CandleInterval}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "{\"ONE_MINUTE\": *, \"THREE_MINUTES\": *, \"FIVE_MINUTES\": *, \"FIFTEEN_MINUTES\": *, \"THIRTY_MINUTES\": *, \"ONE_HOUR\": *, \"FOUR_HOURS\": *, \"ONE_DAY\": *, \"SEVEN_DAYS\": *, \"ONE_MONTH\": *}"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "class",
    "name": "HitBTC",
    "memberof": "core/exchanges/hitBTC.ts",
    "static": true,
    "longname": "core/exchanges/hitBTC.ts~HitBTC",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/exchanges/hitBTC.ts",
    "importStyle": "HitBTC",
    "description": "The HitBTC class represent the HitBTC exchange",
    "lineNumber": 29,
    "interface": false,
    "extends": [
      "core/exchanges/baseExchange.js~BaseExchange"
    ]
  },
  {
    "__docId__": 137,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#constructor",
    "access": "public",
    "description": "Creates a new HitBTC exchange",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pubKey",
        "description": "the public key for connecting"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "secKey",
        "description": "the secret key for connecting"
      }
    ]
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "pubKey",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#pubKey",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "secKey",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#secKey",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "mapper",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#mapper",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "IResponseMapper"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "sequence",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#sequence",
    "access": "public",
    "description": "",
    "lineNumber": 33,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "subscribeCandles",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#subscribeCandles",
    "access": "public",
    "description": "",
    "lineNumber": 134,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "subscribeOrderbook",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#subscribeOrderbook",
    "access": "public",
    "description": "",
    "lineNumber": 139,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "subscribeReports",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#subscribeReports",
    "access": "public",
    "description": "",
    "lineNumber": 141,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "getInstance",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/exchanges/hitBTC.ts~HitBTC.getInstance",
    "access": "public",
    "description": "Creates a singleton instance of HitBTC",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "pKey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "sKey",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "adjustOrder",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#adjustOrder",
    "access": "public",
    "description": "",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "cancelOrder",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#cancelOrder",
    "access": "public",
    "description": "",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "connect",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#connect",
    "access": "public",
    "description": "",
    "lineNumber": 76,
    "params": [],
    "return": null
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "createOrder",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#createOrder",
    "access": "public",
    "description": "",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "OrderSide"
        ],
        "spread": false,
        "optional": false,
        "name": "side",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "loadCurrencies",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#loadCurrencies",
    "access": "public",
    "description": "",
    "lineNumber": 95,
    "params": [],
    "return": null
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "login",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#login",
    "access": "public",
    "description": "Authenticates user on exchange using secure signed nonce",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "publicKey",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "privateKey",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "onUpdateCandles",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#onUpdateCandles",
    "access": "public",
    "description": "",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ICandleInterval"
        ],
        "spread": false,
        "optional": false,
        "name": "interval",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Extract"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "onUpdateOrderbook",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#onUpdateOrderbook",
    "access": "public",
    "description": "",
    "lineNumber": 121,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrderbookData"
        ],
        "spread": false,
        "optional": false,
        "name": "response",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Extract"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "onConnect",
    "memberof": "core/exchanges/hitBTC.ts~HitBTC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTC.ts~HitBTC#onConnect",
    "access": "public",
    "description": "",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "connection"
        ],
        "spread": false,
        "optional": false,
        "name": "conn",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 156,
    "kind": "file",
    "name": "core/exchanges/hitBTCMapper.ts",
    "content": "import {EventEmitter} from \"events\";\nimport moment from \"moment\";\nimport {Error} from \"tslint/lib/error\";\nimport {IMessage} from \"websocket\";\nimport {ICandle, ICandleInterval} from \"../candleCollection\";\nimport logger from \"../logger\";\nimport {IOrderbookEntry} from \"../orderbook\";\nimport {OrderSide, OrderStatus, OrderTimeInForce, OrderType, ReportType} from \"../orderInterface\";\nimport {Pair} from \"../types/pair\";\nimport BaseExchange, {IResponseMapper} from \"./baseExchange\";\nimport {CandleInterval} from \"./hitBTC\";\n\nexport interface IHitBTCOrderbookResponse {\n    jsonrpc: string;\n    method: string;\n    params: {\n        ask: IOrderbookEntry[],\n        bid: IOrderbookEntry[],\n        sequence: number,\n        symbol: string,\n    };\n}\n\ninterface IHitBTCCandlesResponse {\n    jsonrpc: string;\n    method: string;\n    params: {\n        data: Array<{\n            close: string;\n            max: string;\n            min: string;\n            open: string;\n            timestamp: string;\n            volume: string;\n            volumeQuote: string;\n        }>;\n        period: string;\n        symbol: string;\n    };\n}\n\ninterface IHitBTCAuthenticateResponse {\n    id: string;\n    jsonrpc: string;\n    result: boolean;\n}\n\ninterface IHitBTCGetSymbolsResponse {\n    id: string;\n    jsonrpc: string;\n    result: Array<{\n        baseCurrency: string;\n        feeCurrency: string;\n        id: string;\n        provideLiquidityRate: string;\n        quantityIncrement: string;\n        quoteCurrency: string;\n        takeLiquidityRate: string;\n        tickSize: string;\n    }>;\n}\n\ninterface IHitBTCReportResponse {\n    jsonrpc: string;\n    method: string;\n    params: Array<{\n        clientOrderId: string;\n        createdAt: string;\n        cumQuantity: string;\n        id: string;\n        originalRequestClientOrderId?: string;\n        postOnly: boolean;\n        price: string;\n        quantity: string;\n        reportType: string;\n        side: string;\n        status: string;\n        symbol: string;\n        timeInForce: string;\n        type: string;\n        updatedAt: string;\n    }>;\n}\n\n/**\n * The HitBTCMapper maps incoming api events and wraps them with additional checks/logic\n */\nexport default class HitBTCMapper extends EventEmitter implements IResponseMapper {\n\n    /**\n     * Create a new HitBTCMapper\n     * @param {BaseExchange} exchange the exchange to map events from\n     */\n    constructor(private exchange: BaseExchange) {\n        super();\n\n        // Listen for all events that onReceive will be throwing..\n        this.on(\"api.snapshotCandles\", data => this.onUpdateCandles(data, \"set\"));\n        this.on(\"api.updateCandles\", data => this.onUpdateCandles(data, \"update\"));\n        this.on(\"api.snapshotOrderbook\", data => this.onUpdateOrderbook(data, \"setOrders\"));\n        this.on(\"api.updateOrderbook\", data => this.onUpdateOrderbook(data, \"addIncrement\"));\n        this.on(\"api.report\", data => this.onReport(data));\n        this.on(\"api.login\", data => this.onLogin(data));\n        this.on(\"api.getSymbols\", data => this.onGetSymbols(data)); // @TODO fix!\n    }\n\n    /**\n     * Removes HitBTCMapper listeners\n     */\n    destroy(): void {\n        this.removeAllListeners();\n    }\n\n    /**\n     * Emits received message as api event\n     * @param {IMessage} msg\n     */\n    onReceive(msg: IMessage): void {\n        if (msg.type !== \"utf8\") {\n            throw new Error(\"Response is not UTF8!\");\n        }\n\n        if (msg.utf8Data) {\n            const d = JSON.parse(msg.utf8Data);\n            this.emit(`api.${d.method || d.id}`, d);\n        }\n    }\n\n    /**\n     * Maps HitBTC data to candle collection\n     * @param {IHitBTCCandlesResponse} data the date from hitBTC\n     * @returns {ICandle[]} the candle collection\n     */\n    private mapCandles(data: IHitBTCCandlesResponse): ICandle[] {\n        return data.params.data.map<ICandle>(candle => ({\n            close: parseFloat(candle.close),\n            high: parseFloat(candle.max),\n            low: parseFloat(candle.min),\n            open: parseFloat(candle.open),\n            timestamp: moment(candle.timestamp).second(0).millisecond(0),\n            volume: parseFloat(candle.volumeQuote),\n        }));\n    }\n\n    /**\n     * Wraps the returning symbols (allowed pairs)\n     * @param {IHitBTCGetSymbolsResponse} response\n     */\n    private onGetSymbols(response: IHitBTCGetSymbolsResponse): void {\n        const result = response.result.map(({id, tickSize, quantityIncrement, baseCurrency, quoteCurrency}) => ({\n            id: [baseCurrency, quoteCurrency] as Pair,\n            quantityIncrement: parseFloat(quantityIncrement),\n            tickSize: parseFloat(tickSize),\n        }));\n        this.exchange.onCurrenciesLoaded(result);\n    }\n\n    /**\n     * Wraps login callback\n     * @param {IHitBTCAuthenticateResponse} data\n     */\n    private onLogin(data: IHitBTCAuthenticateResponse): void {\n        this.exchange.isAuthenticated = data.result;\n        this.exchange.isReady();\n    }\n\n    /**\n     * Wraps incoming report (order updates)\n     * @param {IHitBTCReportResponse} data report data\n     */\n    private onReport(data: IHitBTCReportResponse): void {\n        data.params.forEach(report => {\n            this.exchange.onReport({\n                id: report.clientOrderId,\n                originalId: (report.originalRequestClientOrderId) ? report.originalRequestClientOrderId : undefined,\n                createdAt: moment(report.createdAt),\n                price: parseFloat(report.price),\n                quantity: parseFloat(report.quantity),\n                reportType: report.reportType as ReportType,\n                side: report.side as OrderSide,\n                status: report.status as OrderStatus,\n                pair: this.exchange.currencies[report.symbol].id,\n                timeInForce: report.timeInForce as OrderTimeInForce,\n                type: report.type as OrderType,\n                updatedAt: moment(report.updatedAt),\n            });\n        });\n    }\n\n    /**\n     * Wraps incoming updated candles\n     * @param {IHitBTCCandlesResponse} data the candles\n     * @param {\"set\" | \"update\"} method overwrite or update\n     */\n    private onUpdateCandles(data: IHitBTCCandlesResponse, method: \"set\" | \"update\") {\n        let interval: ICandleInterval | undefined;\n        Object.keys(CandleInterval).some(key => {\n            if (CandleInterval[key].code === data.params.period) {\n                interval = CandleInterval[key];\n                return true;\n            }\n            return false;\n        });\n\n        if (interval !== undefined) {\n            const pair = this.exchange.currencies[data.params.symbol].id;\n            return this.exchange.onUpdateCandles(pair, this.mapCandles(data), interval, method);\n        }\n\n        logger.debug(`Interval: \"${data.params.period}\" is not recognized by the system. The exchange callback \"onUpdateCandles\" was not triggered.`);\n    }\n\n    /**\n     * Wraps incoming orderbook\n     * @param {{ask: IOrderbookEntry[]; bid: IOrderbookEntry[]; sequence: number; symbol: string}} ob the orderbook\n     * @param {\"addIncrement\" | \"setOrders\"} method update or overwrite\n     */\n    private onUpdateOrderbook({params: ob}: IHitBTCOrderbookResponse, method: \"addIncrement\" | \"setOrders\"): void {\n        this.exchange.onUpdateOrderbook({\n            ask: ob.ask,\n            bid: ob.bid,\n            pair: this.exchange.currencies[ob.symbol].id,\n            sequence: ob.sequence,\n        }, method);\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/exchanges/hitBTCMapper.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 157,
    "kind": "class",
    "name": "HitBTCMapper",
    "memberof": "core/exchanges/hitBTCMapper.ts",
    "static": true,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/exchanges/hitBTCMapper.ts",
    "importStyle": "HitBTCMapper",
    "description": "The HitBTCMapper maps incoming api events and wraps them with additional checks/logic",
    "lineNumber": 88,
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 158,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#constructor",
    "access": "public",
    "description": "Create a new HitBTCMapper",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "BaseExchange"
        ],
        "spread": false,
        "optional": false,
        "name": "exchange",
        "description": "the exchange to map events from"
      }
    ]
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "exchange",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#exchange",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "destroy",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#destroy",
    "access": "public",
    "description": "Removes HitBTCMapper listeners",
    "lineNumber": 110,
    "params": [],
    "return": null
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "onReceive",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#onReceive",
    "access": "public",
    "description": "Emits received message as api event",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "IMessage"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "mapCandles",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#mapCandles",
    "access": "public",
    "description": "Maps HitBTC data to candle collection",
    "lineNumber": 134,
    "params": [
      {
        "nullable": null,
        "types": [
          "IHitBTCCandlesResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "onGetSymbols",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#onGetSymbols",
    "access": "public",
    "description": "Wraps the returning symbols (allowed pairs)",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "IHitBTCGetSymbolsResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "response",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "onLogin",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#onLogin",
    "access": "public",
    "description": "Wraps login callback",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "IHitBTCAuthenticateResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "onReport",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#onReport",
    "access": "public",
    "description": "Wraps incoming report (order updates)",
    "lineNumber": 171,
    "params": [
      {
        "nullable": null,
        "types": [
          "IHitBTCReportResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "onUpdateCandles",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#onUpdateCandles",
    "access": "public",
    "description": "Wraps incoming updated candles",
    "lineNumber": 195,
    "params": [
      {
        "nullable": null,
        "types": [
          "IHitBTCCandlesResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "onUpdateOrderbook",
    "memberof": "core/exchanges/hitBTCMapper.ts~HitBTCMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/hitBTCMapper.ts~HitBTCMapper#onUpdateOrderbook",
    "access": "public",
    "description": "Wraps incoming orderbook",
    "lineNumber": 218,
    "params": [
      {
        "nullable": null,
        "types": [
          "IHitBTCOrderbookResponse"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 168,
    "kind": "file",
    "name": "core/exchanges/localExchange.ts",
    "content": "import {ICandle} from \"../candleCollection\";\nimport {IOrder, OrderSide, OrderStatus, OrderTimeInForce, OrderType, ReportType} from \"../orderInterface\";\nimport {Pair} from \"../types/pair\";\nimport BaseExchange from \"./baseExchange\";\n\nexport interface IAssetMap {\n    [key: string]: number;\n}\n\n/**\n * The LocalExchange resembles a local dummy marketplace for\n * strategy testing\n */\nexport default class LocalExchange extends BaseExchange {\n\n    private static instance?: LocalExchange;\n    private assets: IAssetMap = new Proxy<IAssetMap>({\n        USD: 100000,\n    }, {get: (target, p: PropertyKey): any => p in target ? target[p.toString()] : 0});\n    private currentCandle?: ICandle;\n    private filledOrders: IOrder[] = [];\n\n    /**\n     * Creates a new LocalExchange\n     */\n    constructor() {\n        super();\n\n        this.prependListener(\"app.updateCandles\", (candles: ICandle[]) => this.processOpenOrders(candles[0]));\n        this.on(\"app.report\", (order: IOrder) => this.updateAssets(order));\n    }\n\n    /**\n     * Returns singleton instance of local exchange\n     * @returns {LocalExchange} the new local exchange\n     */\n    static getInstance() {\n        if (!LocalExchange.instance) {\n            LocalExchange.instance = new LocalExchange();\n        }\n        return LocalExchange.instance;\n    }\n\n    adjustOrder(order: IOrder, price: number, qty: number): void {\n        if (!this.currentCandle) {\n            throw new Error(\"Current candle undefined. Emit candles before adjusting an order.\");\n        }\n\n        const newOrder: IOrder = {\n            ...order,\n            id: this.generateOrderId(order.pair),\n            reportType: ReportType.REPLACED,\n            updatedAt: this.currentCandle.timestamp,\n            type: OrderType.LIMIT,\n            originalId: order.id,\n            quantity: qty,\n            price,\n        };\n\n        const isAllowed = newOrder.side === OrderSide.BUY ? this.isBuyAllowed.bind(this) : this.isSellAllowed.bind(this);\n        if (!isAllowed(newOrder, order)) return;\n\n        this.setOrderInProgress(order.id);\n        this.onReport(newOrder);\n    }\n\n    cancelOrder(order: IOrder): void {\n        this.setOrderInProgress(order.id);\n\n        const canceledOrder: IOrder = {\n            ...order,\n            reportType: ReportType.CANCELED,\n        };\n\n        this.onReport(canceledOrder);\n    }\n\n    createOrder(pair: Pair, price: number, qty: number, side: OrderSide): void {\n        if (!this.currentCandle) {\n            throw new Error(\"Current candle undefined. Emit candles before creating an order.\");\n        }\n\n        const orderId = this.generateOrderId(pair);\n        const candleTime = this.currentCandle.timestamp;\n\n        const order: IOrder = {\n            createdAt: candleTime,\n            updatedAt: candleTime,\n            status: OrderStatus.NEW,\n            timeInForce: OrderTimeInForce.GOOD_TILL_CANCEL,\n            id: orderId,\n            type: OrderType.LIMIT,\n            reportType: ReportType.NEW,\n            side,\n            pair,\n            quantity: qty,\n            price,\n        };\n\n        const isAllowed = order.side === OrderSide.BUY ? this.isBuyAllowed.bind(this) : this.isSellAllowed.bind(this);\n        if (!isAllowed(order)) return;\n\n        this.setOrderInProgress(orderId);\n        this.onReport(order);\n    }\n\n    /**\n     * Emits a collection of candles from a local file as if they were\n     * sent from a real exchange\n     * @param {ICandle[]} candles\n     * @returns {Promise<void>} promise\n     */\n    async emitCandles(candles: ICandle[]) {\n        const normCandles: ICandle[] = (candles[candles.length - 1].timestamp.isBefore(candles[0].timestamp))\n            ? candles.reverse()\n            : candles;\n\n        normCandles.reduce<ICandle[]>((acc, val, idx) => {\n            const processedCandles = [val, ...acc];\n            this.currentCandle = val;\n            this.emit(\"app.updateCandles\", processedCandles);\n            return processedCandles;\n        }, []);\n    }\n\n    isReady(): boolean {\n        this.emit(\"ready\");\n        return true;\n    }\n\n    loadCurrencies = (): void => undefined;\n\n    // noinspection JSUnusedGlobalSymbols\n    onUpdateCandles = (): void => undefined;\n\n    // noinspection JSUnusedGlobalSymbols\n    onUpdateOrderbook = (): void => undefined;\n\n    /**\n     * Checks if open order can be filled on each price update\n     * @param {ICandle} candle the current candle\n     */\n    processOpenOrders(candle: ICandle): void {\n        const openOrders: IOrder[] = [];\n        this.openOrders.forEach(oo => {\n            if (oo.createdAt.isAfter(candle.timestamp)) {\n                return openOrders.push(oo); // Candle should be newer than order!\n            }\n\n            const order = {...oo, reportType: ReportType.TRADE, status: OrderStatus.FILLED};\n            if (oo.side === OrderSide.BUY && candle.low < oo.price) {\n                this.filledOrders.push(order);\n                return this.onReport(order);\n            }\n\n            if (oo.side === OrderSide.SELL && candle.high > oo.price) {\n                this.filledOrders.push(order);\n                return this.onReport(order);\n            }\n\n            openOrders.push(oo);\n        });\n        this.openOrders = openOrders;\n    }\n\n    subscribeCandles = (): void => undefined;\n\n    subscribeOrderbook = (): void => undefined;\n\n    subscribeReports = (): void => undefined;\n\n    /**\n     * Calculates total price of order\n     * @param {IOrder} order the order\n     * @returns {number} total price\n     */\n    private getOrderPrice(order: IOrder) {\n        return order.price * order.quantity;\n    }\n\n    /**\n     * Checks if funds are sufficient for a buy\n     * @param {IOrder} order the order to verify\n     * @param {IOrder} oldOrder\n     * @returns {boolean} is buy allowed\n     */\n    private isBuyAllowed(order: IOrder, oldOrder?: IOrder): boolean {\n        const orderPrice: number = this.getOrderPrice(order);\n\n        return this.assets[order.pair[1]] > orderPrice;\n    }\n\n    /**\n     * Checks if current quantity of currency in possession\n     * if sufficient for given sell order\n     * @param {IOrder} order the order to verify\n     * @param {IOrder} oldOrder\n     * @returns {boolean} is sell allowed\n     */\n    private isSellAllowed(order: IOrder, oldOrder?: IOrder): boolean {\n        const orderPrice: number = this.getOrderPrice(order);\n        const oldOrderPrice = (oldOrder) ? this.getOrderPrice(oldOrder) : 0;\n\n        return this.assets[order.pair[0]] > order.quantity;\n    }\n\n    // @TODO test and verify logic..\n    /**\n     * Updates the assets on the exchange for given new order\n     * @param {IOrder} order new order\n     * @param {IOrder} oldOrder old order\n     */\n    private updateAssets(order: IOrder, oldOrder?: IOrder) {\n        const [target, source] = order.pair;\n\n        // if (order.side === OrderSide.SELL) {\n        //     target = order.pair[1];\n        //     source = order.pair[0];\n        // }\n\n        if (ReportType.REPLACED === order.reportType && oldOrder) {\n            // @TODO ..\n        } else if (ReportType.NEW === order.reportType) {\n            if (order.side === OrderSide.BUY) {\n                this.assets[source] -= this.getOrderPrice(order);\n            } else {\n                this.assets[target] -= order.quantity;\n            }\n        } else if (ReportType.TRADE === order.reportType && OrderStatus.FILLED === order.status) {\n            if (order.side === OrderSide.BUY) {\n                this.assets[target] += order.quantity;\n            } else {\n                this.assets[source] += this.getOrderPrice(order);\n            }\n            console.log(this.assets);\n        } else if ([ReportType.CANCELED, ReportType.EXPIRED, ReportType.SUSPENDED].indexOf(order.reportType) > -1) {\n            this.assets[source] += this.getOrderPrice(order);\n        }\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/exchanges/localExchange.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 169,
    "kind": "class",
    "name": "LocalExchange",
    "memberof": "core/exchanges/localExchange.ts",
    "static": true,
    "longname": "core/exchanges/localExchange.ts~LocalExchange",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/exchanges/localExchange.ts",
    "importStyle": "LocalExchange",
    "description": "The LocalExchange resembles a local dummy marketplace for\nstrategy testing",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "core/exchanges/baseExchange.js~BaseExchange"
    ]
  },
  {
    "__docId__": 170,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#constructor",
    "access": "public",
    "description": "Creates a new LocalExchange",
    "lineNumber": 14
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "assets",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#assets",
    "access": "public",
    "description": "",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "IAssetMap"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "name": "filledOrders",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#filledOrders",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "member",
    "name": "loadCurrencies",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#loadCurrencies",
    "access": "public",
    "description": "",
    "lineNumber": 131,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "member",
    "name": "onUpdateCandles",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#onUpdateCandles",
    "access": "public",
    "description": "",
    "lineNumber": 134,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "onUpdateOrderbook",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#onUpdateOrderbook",
    "access": "public",
    "description": "",
    "lineNumber": 137,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "subscribeCandles",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#subscribeCandles",
    "access": "public",
    "description": "",
    "lineNumber": 166,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "member",
    "name": "subscribeOrderbook",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#subscribeOrderbook",
    "access": "public",
    "description": "",
    "lineNumber": 168,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "member",
    "name": "subscribeReports",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#subscribeReports",
    "access": "public",
    "description": "",
    "lineNumber": 170,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "getInstance",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/exchanges/localExchange.ts~LocalExchange.getInstance",
    "access": "public",
    "description": "Returns singleton instance of local exchange",
    "lineNumber": 37,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "adjustOrder",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#adjustOrder",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "cancelOrder",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#cancelOrder",
    "access": "public",
    "description": "",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "createOrder",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#createOrder",
    "access": "public",
    "description": "",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "OrderSide"
        ],
        "spread": false,
        "optional": false,
        "name": "side",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "emitCandles",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#emitCandles",
    "access": "public",
    "description": "Emits a collection of candles from a local file as if they were\nsent from a real exchange",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "currentCandle",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#currentCandle",
    "access": "public",
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "isReady",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#isReady",
    "access": "public",
    "description": "",
    "lineNumber": 126,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "processOpenOrders",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#processOpenOrders",
    "access": "public",
    "description": "Checks if open order can be filled on each price update",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "ICandle"
        ],
        "spread": false,
        "optional": false,
        "name": "candle",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "openOrders",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#openOrders",
    "access": "public",
    "description": null,
    "lineNumber": 237,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "getOrderPrice",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#getOrderPrice",
    "access": "public",
    "description": "Calculates total price of order",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "isBuyAllowed",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#isBuyAllowed",
    "access": "public",
    "description": "Checks if funds are sufficient for a buy",
    "lineNumber": 187,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "oldOrder",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "isSellAllowed",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#isSellAllowed",
    "access": "public",
    "description": "Checks if current quantity of currency in possession\nif sufficient for given sell order",
    "lineNumber": 200,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "oldOrder",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "updateAssets",
    "memberof": "core/exchanges/localExchange.ts~LocalExchange",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/exchanges/localExchange.ts~LocalExchange#updateAssets",
    "access": "public",
    "description": "Updates the assets on the exchange for given new order",
    "lineNumber": 213,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "oldOrder",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 192,
    "kind": "file",
    "name": "core/liveTrader.ts",
    "content": "import {IExchange} from \"./exchanges/exchangeInterface\";\nimport {IOrder} from \"./orderInterface\";\nimport SockTrader from \"./sockTrader\";\n\n/**\n * The LiveTrader enables you to run your strategy against\n * a live environment on an exchange\n */\nexport default class LiveTrader extends SockTrader {\n\n    /**\n     * Adds an exchange\n     * @param {IExchange} exchange the exchange to add\n     * @returns {this}\n     */\n    addExchange(exchange: IExchange): this {\n        this.exchange = exchange;\n\n        return this;\n    }\n\n    async start(): Promise<void> {\n        await super.start();\n\n        if (!this.exchange) {\n            throw new Error(\"No exchange defined!\");\n        }\n\n        if (!this.eventsBound) {\n            this.subscribeToExchangeEvents(this.strategyConfigurations);\n\n            this.strategyConfigurations.forEach(c => {\n                const strategy = new c.strategy(c.pair, this.exchange);\n                this.bindStrategyToExchange(strategy);\n                this.bindExchangeToStrategy(strategy);\n                this.bindExchangeToSocketServer();\n            });\n\n            this.eventsBound = true;\n        }\n\n        // @TODO cannot connect multiple times to the same exchange\n        // -> start function might be called multiple times by the dashboard?\n        this.exchange.connect();\n    }\n\n    private bindExchangeToSocketServer() {\n        this.exchange.on(\"app.report\", (order: IOrder) => this.sendToWebServer(\"REPORT\", order));\n        this.exchange.on(\"app.updateCandles\", candles => this.sendToWebServer(\"CANDLE_UPDATE\", candles));\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/liveTrader.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 193,
    "kind": "class",
    "name": "LiveTrader",
    "memberof": "core/liveTrader.ts",
    "static": true,
    "longname": "core/liveTrader.ts~LiveTrader",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/liveTrader.ts",
    "importStyle": "LiveTrader",
    "description": "The LiveTrader enables you to run your strategy against\na live environment on an exchange",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "core/sockTrader.js~SockTrader"
    ]
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "addExchange",
    "memberof": "core/liveTrader.ts~LiveTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/liveTrader.ts~LiveTrader#addExchange",
    "access": "public",
    "description": "Adds an exchange",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "IExchange"
        ],
        "spread": false,
        "optional": false,
        "name": "exchange",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "member",
    "name": "exchange",
    "memberof": "core/liveTrader.ts~LiveTrader",
    "static": false,
    "longname": "core/liveTrader.ts~LiveTrader#exchange",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "start",
    "memberof": "core/liveTrader.ts~LiveTrader",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "core/liveTrader.ts~LiveTrader#start",
    "access": "public",
    "description": "",
    "lineNumber": 22,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "eventsBound",
    "memberof": "core/liveTrader.ts~LiveTrader",
    "static": false,
    "longname": "core/liveTrader.ts~LiveTrader#eventsBound",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "bindExchangeToSocketServer",
    "memberof": "core/liveTrader.ts~LiveTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/liveTrader.ts~LiveTrader#bindExchangeToSocketServer",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "params": [],
    "return": null
  },
  {
    "__docId__": 199,
    "kind": "file",
    "name": "core/logger.ts",
    "content": "import moment from \"moment\";\nimport {createLogger, format, transports} from \"winston\";\nconst defaults = {silent: process.env.NODE_ENV === \"test\"};\n\nconst stringFormat = format.printf(info => {\n    const {timestamp, level, message, ...args} = info;\n    const ts = moment(timestamp).format(\"YYYY-MM-DD HH:mm:ss\");\n    return `${ts} [${level}]: ${message} ${Object.keys(args).length ? JSON.stringify(args, undefined, 2) : \"\"}`;\n});\n\nconst consoleFormat = format.combine(\n    format.colorize(),\n    format.timestamp(),\n    format.align(),\n    stringFormat,\n);\n\nconst fileFormat = format.combine(consoleFormat, format.uncolorize());\n\nconst getFileTransport = (level: any, file: any) => new transports.File({\n    ...defaults,\n    filename: `./src/logs/${file}.log`,\n    format: fileFormat,\n    level,\n});\n\nconst getConsoleTransport = (level: any) => new transports.Console({...defaults, format: consoleFormat, level});\n\nconst errorLogger = createLogger({\n    levels: {error: 3},\n    transports: [getFileTransport(\"error\", \"error\"), getConsoleTransport(\"error\")],\n});\n\nconst infoLogger = createLogger({\n    levels: {info: 2},\n    transports: [getFileTransport(\"info\", \"system\"), getConsoleTransport(\"info\")],\n});\n\nconst debugLogger = createLogger({\n    levels: {debug: 1},\n    transports: [getFileTransport(\"debug\", \"debug\")],\n});\n\nconst inputLogger = createLogger({\n    levels: {input: 0},\n    transports: [getFileTransport(\"input\", \"input\")],\n});\n\nexport default {\n    debug: (msg: string, ...meta: any[]) => debugLogger.debug(msg, meta),\n    error: (msg: string, ...meta: any[]) => errorLogger.error(msg, meta),\n    info: (msg: string, ...meta: any[]) => infoLogger.info(msg, meta),\n    input: (msg: string, ...meta: any[]) => inputLogger.input(msg, meta),\n};\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/logger.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 200,
    "kind": "variable",
    "name": "defaults",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~defaults",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "{\"silent\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 201,
    "kind": "variable",
    "name": "stringFormat",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~stringFormat",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "name": "consoleFormat",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~consoleFormat",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 203,
    "kind": "variable",
    "name": "fileFormat",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~fileFormat",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "function",
    "name": "getFileTransport",
    "memberof": "core/logger.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/logger.ts~getFileTransport",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "level",
        "types": [
          "*"
        ]
      },
      {
        "name": "file",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 205,
    "kind": "function",
    "name": "getConsoleTransport",
    "memberof": "core/logger.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/logger.ts~getConsoleTransport",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "level",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 206,
    "kind": "variable",
    "name": "errorLogger",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~errorLogger",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 207,
    "kind": "variable",
    "name": "infoLogger",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~infoLogger",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 208,
    "kind": "variable",
    "name": "debugLogger",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~debugLogger",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 209,
    "kind": "variable",
    "name": "inputLogger",
    "memberof": "core/logger.ts",
    "static": true,
    "longname": "core/logger.ts~inputLogger",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/logger.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 210,
    "kind": "file",
    "name": "core/orderInterface.ts",
    "content": "import {Moment} from \"moment\";\nimport {Pair} from \"./types/pair\";\n\nexport enum OrderSide {\n    BUY = \"buy\",\n    SELL = \"sell\",\n}\n\nexport enum OrderStatus {\n    NEW = \"new\",\n    SUSPENDED = \"suspended\",\n    CANCELED = \"canceled\",\n    EXPIRED = \"expired\",\n    PARTIALLY_FILLED = \"partiallyFilled\",\n    FILLED = \"filled\",\n}\n\nexport enum ReportType {\n    NEW = \"new\",\n    SUSPENDED = \"suspended\",\n    CANCELED = \"canceled\",\n    EXPIRED = \"expired\",\n    STATUS = \"status\",\n    TRADE = \"trade\",\n    REPLACED = \"replaced\",\n}\n\nexport enum OrderType {\n    LIMIT = \"limit\",\n    MARKET = \"market\",\n}\n\nexport enum OrderTimeInForce {\n    GOOD_TILL_CANCEL = \"GTC\",\n    IMMEDIATE_OR_CANCEL = \"IOC\",\n    FILL_OR_KILL = \"FOK\",\n    DAY = \"DAY\",\n    GOOD_TILL_DATE = \"GTD\",\n}\n\nexport interface IOrder {\n    createdAt: Moment;\n    id: string;\n    originalId?: string;\n    pair: Pair;\n    price: number;\n    quantity: number;\n    reportType: ReportType;\n    side: OrderSide;\n    status: OrderStatus;\n    timeInForce: OrderTimeInForce;\n    type: OrderType;\n    updatedAt: Moment;\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/orderInterface.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 211,
    "kind": "file",
    "name": "core/orderbook.ts",
    "content": "import {Decimal} from \"decimal.js-light\";\nimport reverse from \"lodash.reverse\";\nimport sortBy from \"lodash.sortby\";\nimport {Pair} from \"./types/pair\";\n\nexport enum Operator {\n    PLUS = \"+\",\n    MINUS = \"-\",\n}\n\nexport enum OrderbookSide {\n    BID = \"bid\",\n    ASK = \"ask\",\n}\n\nexport interface IOrderbookEntry {\n    price: number;\n    size: number;\n}\n\nexport interface IOrderbook {\n    addIncrement(ask: IOrderbookEntry[], bid: IOrderbookEntry[]): void;\n\n    getEntries(side: OrderbookSide, amount: number): IOrderbookEntry[];\n\n    setOrders(ask: IOrderbookEntry[], bid: IOrderbookEntry[]): void;\n}\n\n/**\n * @class OrderbookBase\n * @classdesc Order book to be used within an exchange class\n */\n\n/**\n * The Orderbook resembles the orders currently active on\n * and exchange\n */\nexport default class Orderbook implements IOrderbook {\n\n    ask: IOrderbookEntry[] = [];\n    bid: IOrderbookEntry[] = [];\n\n    constructor(protected pair: Pair, protected precision = 8) {\n    }\n\n    /**\n     * Calculate bid/ask spread in %\n     * @param {number} bid price bid\n     * @param {number} ask price asked\n     * @returns {number} percentage spread bid/ask\n     */\n    static getBidAskSpreadPerc(bid: number, ask: number): number {\n        const increase: Decimal = new Decimal(ask).minus(bid);\n        return increase.dividedBy(bid).toNumber();\n    }\n\n    /**\n     * Add increment to internal order book properties\n     * sort the orders by value\n     * @param {IOrderbookEntry[]} ask the price asked\n     * @param {IOrderbookEntry[]} bid the price bid\n     */\n    addIncrement(ask: IOrderbookEntry[], bid: IOrderbookEntry[]): void {\n        this.ask = sortBy(this.applyIncrement(this.ask, ask), [\"price\"]);\n        this.bid = reverse(sortBy(this.applyIncrement(this.bid, bid), [\"price\"]));\n    }\n\n    /**\n     * Calculate a price higher/lower then the given price\n     * @param {number} price\n     * @param {('+'|'-')} operator\n     * @param {number} [ticks=1]\n     * @returns {number}\n     */\n    getAdjustedPrice(price: number, operator: Operator, ticks = 1): number {\n        const decPrice: Decimal = new Decimal(price);\n\n        const func = (operator === Operator.PLUS)\n            ? (a: Decimal, b: Decimal | number) => a.plus(b)\n            : (a: Decimal, b: Decimal | number) => a.minus(b);\n\n        const m: number = Math.pow(10, this.precision);\n        const natNum: Decimal = decPrice.times(m);\n        return func(natNum, ticks).dividedBy(m).toNumber();\n    }\n\n    /**\n     * Scans the in memory orderBook for the first x entries\n     * @param {('bid'|'ask')} side\n     * @param {number} amount\n     * @returns {IOrderbookEntry[]}\n     */\n    getEntries(side: \"bid\" | \"ask\", amount = 1): IOrderbookEntry[] {\n        return this[side].slice(0, Math.abs(amount));\n    }\n\n    /**\n     * Returns absolute satoshi difference between num1 and num2\n     * @param {string|number} num1\n     * @param {string|number} num2\n     * @returns {number}\n     */\n    getSatDiff(num1: number, num2: number): number {\n        const multipl: number = Math.pow(10, this.precision);\n        return Math.abs(new Decimal(num1).times(multipl).toNumber() - new Decimal(num2).times(multipl).toNumber());\n    }\n\n    /**\n     * Immediately set all orders in order book\n     * @param {IOrderbookEntry[]} ask\n     * @param {IOrderbookEntry[]} bid\n     */\n    setOrders(ask: IOrderbookEntry[], bid: IOrderbookEntry[]): void {\n        this.ask = sortBy(ask, [\"price\"]);\n        this.bid = reverse(sortBy(bid, [\"price\"]));\n    }\n\n    /**\n     * Returns a new side of the orderBook with applied increment\n     * @param {IOrderbookEntry[]} oldBook\n     * @param {IOrderbookEntry[]} inc\n     */\n    private applyIncrement(oldBook: IOrderbookEntry[], inc: IOrderbookEntry[] = []): IOrderbookEntry[] {\n        let newBook: IOrderbookEntry[] = oldBook.slice(0);\n\n        inc.forEach(({price, size}) => {\n\n            // Remove outdated records from copy of oldBook\n            newBook = newBook.filter(v => v.price !== price);\n\n            if (size > 0) {\n                newBook.push({price, size}); // Add updated record to orderBook\n            }\n        });\n\n        return newBook;\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/orderbook.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 212,
    "kind": "class",
    "name": "Orderbook",
    "memberof": "core/orderbook.ts",
    "static": true,
    "longname": "core/orderbook.ts~Orderbook",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/orderbook.ts",
    "importStyle": "Orderbook",
    "description": "",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "OrderbookBase"
      },
      {
        "tagName": "@classdesc",
        "tagValue": "Order book to be used within an exchange class"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 213,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "pair",
    "memberof": "core/orderbook.ts~Orderbook",
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#pair",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "precision",
    "memberof": "core/orderbook.ts~Orderbook",
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#precision",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "ask",
    "memberof": "core/orderbook.ts~Orderbook",
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#ask",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "bid",
    "memberof": "core/orderbook.ts~Orderbook",
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#bid",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "getBidAskSpreadPerc",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/orderbook.ts~Orderbook.getBidAskSpreadPerc",
    "access": "public",
    "description": "Calculate bid/ask spread in %",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "bid",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ask",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "addIncrement",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#addIncrement",
    "access": "public",
    "description": "Add increment to internal order book properties\nsort the orders by value",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "ask",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "bid",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "getAdjustedPrice",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#getAdjustedPrice",
    "access": "public",
    "description": "Calculate a price higher/lower then the given price",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Operator"
        ],
        "spread": false,
        "optional": false,
        "name": "operator",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "ticks",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "getEntries",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#getEntries",
    "access": "public",
    "description": "Scans the in memory orderBook for the first x entries",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "side",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "getSatDiff",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#getSatDiff",
    "access": "public",
    "description": "Returns absolute satoshi difference between num1 and num2",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "setOrders",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#setOrders",
    "access": "public",
    "description": "Immediately set all orders in order book",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "ask",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "bid",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "applyIncrement",
    "memberof": "core/orderbook.ts~Orderbook",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/orderbook.ts~Orderbook#applyIncrement",
    "access": "public",
    "description": "Returns a new side of the orderBook with applied increment",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "oldBook",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "inc",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "file",
    "name": "core/sockTrader.ts",
    "content": "import {ChildProcess} from \"child_process\";\nimport uniqBy from \"lodash.uniqby\";\nimport uniqWith from \"lodash.uniqwith\";\nimport {ICandle, ICandleInterval} from \"./candleCollection\";\nimport {IExchange} from \"./exchanges/exchangeInterface\";\nimport {IOrderbook} from \"./orderbook\";\nimport {IOrder} from \"./orderInterface\";\nimport BaseStrategy, {IAdjustSignal, ISignal, IStrategyClass} from \"./strategy/baseStrategy\";\nimport {Pair} from \"./types/pair\";\nimport spawnServer from \"./web/spawnServer\";\n\nexport interface IStrategyConfig {\n    interval: ICandleInterval;\n    pair: Pair;\n    strategy: IStrategyClass<BaseStrategy>;\n}\n\nexport interface ISockTraderConfig {\n    webServer?: boolean;\n}\n\n/**\n * The SockTrader provides common logic for both:\n * - live trading on an exchange\n * - dummy strategy testing using back testing on\n *   a local exchange\n */\nexport default abstract class SockTrader {\n    protected eventsBound = false;\n    protected exchange!: IExchange;\n    protected strategyConfigurations: IStrategyConfig[] = [];\n    protected webServer?: ChildProcess;\n\n    constructor(protected config: ISockTraderConfig = {webServer: true}) {\n        if (this.config.webServer) {\n            this.webServer = spawnServer();\n            this.webServer.on(\"START_TRADING\", () => this.start());\n        }\n    }\n\n    /**\n     * Adds a strategy\n     * @param {IStrategyConfig} config strategy configuration\n     * @returns {this}\n     */\n    addStrategy(config: IStrategyConfig): this {\n        this.strategyConfigurations.push(config);\n\n        return this;\n    }\n\n    /**\n     * Starts the application\n     * @returns {Promise<void>} promise\n     */\n    async start(): Promise<void> {\n        if (this.strategyConfigurations.length < 1) {\n            throw new Error(\"SockTrader should have at least 1 strategy and at least 1 exchange.\");\n        }\n    }\n\n    /**\n     * Registers the exchange to listen to api events:\n     * - new candles for a pair/interval combination found in given\n     *   configuration\n     * - orderbook changes of a pair found in given configuration\n     * @param {IStrategyConfig[]} config strategy configuration\n     */\n    subscribeToExchangeEvents(config: IStrategyConfig[]): void {\n        const exchange = this.exchange;\n\n        exchange.once(\"ready\", () => exchange.subscribeReports());\n\n        // Be sure to only subscribe once to a certain trading pair.\n        // Even if multiple strategyConfigurations are listening to the same events.\n        // Because we will dispatch the same data to each strategy.\n        const uniquePairs = uniqBy<IStrategyConfig>(config, \"pair\");\n        uniquePairs.forEach(({pair}) => exchange.once(\"ready\", () => exchange.subscribeOrderbook(pair)));\n\n        const uniquePairInterval = uniqWith<IStrategyConfig>(config, (arr, oth) => arr.pair === oth.pair && arr.interval === oth.interval);\n        uniquePairInterval.forEach(({pair, interval}) => exchange.once(\"ready\", () => exchange.subscribeCandles(pair, interval)));\n    }\n\n    /**\n     * Registers the strategies to listen to exchange events:\n     * - report: order update\n     * - update orderbook: change in orderbook\n     * - update candles: change in candles\n     * @param {BaseStrategy} strategy\n     */\n    protected bindExchangeToStrategy(strategy: BaseStrategy): void {\n        const exchange = this.exchange;\n        exchange.on(\"app.report\", (order: IOrder) => strategy.notifyOrder(order));\n        exchange.on(\"app.updateOrderbook\", (orderbook: IOrderbook) => strategy.updateOrderbook(orderbook));\n        exchange.on(\"app.updateCandles\", (candles: ICandle[]) => strategy.updateCandles(candles));\n    }\n\n    /**\n     * Registers the exchange to listen to strategy events:\n     * - signal: buy and sells\n     * - adjust order: adjustment of existing order\n     * @param {BaseStrategy} strategy\n     */\n    protected bindStrategyToExchange(strategy: BaseStrategy): void {\n        const exchange = this.exchange;\n        // @TODO add cancel order event!\n        strategy.on(\"app.signal\", ({symbol, price, qty, side}: ISignal) => exchange.createOrder(symbol, price, qty, side));\n        strategy.on(\"app.adjustOrder\", ({order, price, qty}: IAdjustSignal) => exchange.adjustOrder(order, price, qty));\n    }\n\n    /**\n     * Sends messages to webserver\n     * @param {string} type type of message\n     * @param payload the data\n     */\n    protected sendToWebServer(type: string, payload: any) {\n        if (this.webServer) this.webServer.send({type, payload});\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/sockTrader.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 230,
    "kind": "class",
    "name": "SockTrader",
    "memberof": "core/sockTrader.ts",
    "static": true,
    "longname": "core/sockTrader.ts~SockTrader",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/sockTrader.ts",
    "importStyle": "SockTrader",
    "description": "The SockTrader provides common logic for both:\n- live trading on an exchange\n- dummy strategy testing using back testing on\na local exchange",
    "lineNumber": 28,
    "interface": false
  },
  {
    "__docId__": 231,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/sockTrader.ts~SockTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true
  },
  {
    "__docId__": 232,
    "kind": "member",
    "name": "config",
    "memberof": "core/sockTrader.ts~SockTrader",
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#config",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "member",
    "name": "eventsBound",
    "memberof": "core/sockTrader.ts~SockTrader",
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#eventsBound",
    "access": "public",
    "description": "",
    "lineNumber": 29,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "member",
    "name": "strategyConfigurations",
    "memberof": "core/sockTrader.ts~SockTrader",
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#strategyConfigurations",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "member",
    "name": "webServer",
    "memberof": "core/sockTrader.ts~SockTrader",
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#webServer",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "addStrategy",
    "memberof": "core/sockTrader.ts~SockTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#addStrategy",
    "access": "public",
    "description": "Adds a strategy",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "IStrategyConfig"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "start",
    "memberof": "core/sockTrader.ts~SockTrader",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#start",
    "access": "public",
    "description": "Starts the application",
    "lineNumber": 56,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "subscribeToExchangeEvents",
    "memberof": "core/sockTrader.ts~SockTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#subscribeToExchangeEvents",
    "access": "public",
    "description": "Registers the exchange to listen to api events:\n- new candles for a pair/interval combination found in given\nconfiguration\n- orderbook changes of a pair found in given configuration",
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "bindExchangeToStrategy",
    "memberof": "core/sockTrader.ts~SockTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#bindExchangeToStrategy",
    "access": "public",
    "description": "Registers the strategies to listen to exchange events:\n- report: order update\n- update orderbook: change in orderbook\n- update candles: change in candles",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "BaseStrategy"
        ],
        "spread": false,
        "optional": false,
        "name": "strategy",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "bindStrategyToExchange",
    "memberof": "core/sockTrader.ts~SockTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#bindStrategyToExchange",
    "access": "public",
    "description": "Registers the exchange to listen to strategy events:\n- signal: buy and sells\n- adjust order: adjustment of existing order",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "BaseStrategy"
        ],
        "spread": false,
        "optional": false,
        "name": "strategy",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "sendToWebServer",
    "memberof": "core/sockTrader.ts~SockTrader",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/sockTrader.ts~SockTrader#sendToWebServer",
    "access": "public",
    "description": "Sends messages to webserver",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "payload",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 242,
    "kind": "file",
    "name": "core/strategy/baseStrategy.ts",
    "content": "import {EventEmitter} from \"events\";\nimport {Error} from \"tslint/lib/error\";\nimport {ICandle} from \"../candleCollection\";\nimport {IExchange} from \"../exchanges/exchangeInterface\";\nimport {IOrderbook} from \"../orderbook\";\nimport {IOrder, OrderSide} from \"../orderInterface\";\nimport {Pair} from \"../types/pair\";\n\nexport interface IStrategyClass<T> {\n    new(pair: Pair, exchange: IExchange): T;\n}\n\nexport interface ISignal {\n    price: number;\n    qty: number;\n    side: OrderSide;\n    symbol: Pair;\n}\n\nexport interface IAdjustSignal {\n    order: IOrder;\n    price: number;\n    qty: number;\n}\n\n/**\n * The BaseStrategy holds common logic for your strategies to use\n */\nexport default abstract class BaseStrategy extends EventEmitter {\n\n    protected constructor(public pair: Pair, public exchange: IExchange) {\n        super();\n    }\n\n    /**\n     * Called when exchange confirms and order\n     * @param {IOrder} order the order\n     */\n    notifyOrder(order: IOrder): void {\n        throw new Error(\"Implement method: notifyOrder\");\n    }\n\n    /**\n     * Called on each new candle from exchange\n     * @param {ICandle[]} candles the new candles\n     */\n    updateCandles(candles: ICandle[]): void {\n        throw new Error(\"Implement method: updateCandles\");\n    }\n\n    /**\n     * Called on orderbook update from exchange\n     * @param {IOrderbook} orderBook the new orderbook\n     */\n    updateOrderbook(orderBook: IOrderbook): void {\n        throw new Error(\"Implement method: updateOrderbook\");\n    }\n\n    /**\n     * Fires a adjust existing order event to exchange\n     * @param {IOrder} order the order to adjust\n     * @param {number} price the new price\n     * @param {number} qty the new quantity\n     */\n    protected adjust(order: IOrder, price: number, qty: number): void {\n        this.emit(\"app.adjustOrder\", {order, price, qty} as IAdjustSignal);\n    }\n\n    /**\n     * Fires a buy event to exchange\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {number} price the price a which to buy\n     * @param {number} qty the quantity to buy\n     */\n    protected buy(pair: Pair, price: number, qty: number): void {\n        this.emit(\"app.signal\", {symbol: pair, price, qty, side: OrderSide.BUY} as ISignal);\n    }\n\n    /**\n     * Fires a sell event to exchange\n     * @param {Pair} pair crypto pair (BTC USD/BTC ETH)\n     * @param {number} price the price a which to sell\n     * @param {number} qty the quantity to sell\n     */\n    protected sell(pair: Pair, price: number, qty: number): void {\n        this.emit(\"app.signal\", {symbol: pair, price, qty, side: OrderSide.SELL} as ISignal);\n    }\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/strategy/baseStrategy.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 243,
    "kind": "class",
    "name": "BaseStrategy",
    "memberof": "core/strategy/baseStrategy.ts",
    "static": true,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/strategy/baseStrategy.ts",
    "importStyle": "BaseStrategy",
    "description": "The BaseStrategy holds common logic for your strategies to use",
    "lineNumber": 29,
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 244,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "pair",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#pair",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "member",
    "name": "exchange",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#exchange",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "notifyOrder",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#notifyOrder",
    "access": "public",
    "description": "Called when exchange confirms and order",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "updateCandles",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#updateCandles",
    "access": "public",
    "description": "Called on each new candle from exchange",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "candles",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "updateOrderbook",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#updateOrderbook",
    "access": "public",
    "description": "Called on orderbook update from exchange",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrderbook"
        ],
        "spread": false,
        "optional": false,
        "name": "orderBook",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "adjust",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#adjust",
    "access": "public",
    "description": "Fires a adjust existing order event to exchange",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOrder"
        ],
        "spread": false,
        "optional": false,
        "name": "order",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "buy",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#buy",
    "access": "public",
    "description": "Fires a buy event to exchange",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "sell",
    "memberof": "core/strategy/baseStrategy.ts~BaseStrategy",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/strategy/baseStrategy.ts~BaseStrategy#sell",
    "access": "public",
    "description": "Fires a sell event to exchange",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "Pair"
        ],
        "spread": false,
        "optional": false,
        "name": "pair",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "price",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qty",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 253,
    "kind": "file",
    "name": "core/strategy/utils.ts",
    "content": "type Validator = (a: number, b: number) => boolean;\n\nconst recurValidator = (validator: Validator) => {\n    const recursiveCheck = (a: number[], b: number[], depth = 0): boolean => {\n        if (a[depth] === b[depth]) {\n            return (a.length < depth + 2 || b.length < depth + 2)\n                ? false\n                : recursiveCheck(a, b, depth + 1);\n        }\n\n        return validator(a[depth], b[depth]);\n    };\n    return recursiveCheck;\n};\n\n/**\n * Validates a positive crossover of lineA and lineB\n *\n * VALID SCENARIOS:\n *       o             o\n *     /             /\n * ---o-------o--o--o----\n *  /       /\n * o       o\n *\n * INVALID SCENARIOS:\n *                o          o\n *                 \\       /\n * ----o--o--o------o--o--o----\n *   /        \\\n *  o          o\n *\n * @param {number[]} lineA line to check if it crosses over\n * @param {number[]} lineB line to check if is goes under\n * @returns {boolean} lineA crosses over lineB\n */\nexport function crossUp(lineA: number[], lineB: number[]): boolean {\n    const validate = recurValidator(((a, b) => a < b));\n\n    return ((lineA.length < 2 || lineB.length < 2) || (lineA[0] <= lineB[0]))\n        ? false\n        : validate(lineA, lineB, 1);\n}\n\n/**\n * Validates a negative crossover of lineA and lineB\n *\n * VALID SCENARIOS:\n *  o       o\n *   \\       \\\n * ---o-------o--o--o----\n *     \\             \\\n *      o             o\n *\n * INVALID SCENARIOS:\n *                o          o\n *                 \\       /\n * ----o--o--o------o--o--o----\n *   /        \\\n *  o          o\n *\n * @param {number[]} lineA line to check if is goes under\n * @param {number[]} lineB line to check if it crosses over\n * @returns {boolean} lineA goes under lineB\n */\nexport function crossDown(lineA: number[], lineB: number[]): boolean {\n    const validate = recurValidator(((a, b) => a > b));\n\n    return ((lineA.length < 2 || lineB.length < 2) || (lineA[0] >= lineB[0]))\n        ? false\n        : validate(lineA, lineB, 1);\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/strategy/utils.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 254,
    "kind": "function",
    "name": "recurValidator",
    "memberof": "core/strategy/utils.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/strategy/utils.ts~recurValidator",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/strategy/utils.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "validator",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 255,
    "kind": "function",
    "name": "crossUp",
    "memberof": "core/strategy/utils.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/strategy/utils.ts~crossUp",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/strategy/utils.ts",
    "importStyle": "{crossUp}",
    "description": "Validates a positive crossover of lineA and lineB\n\nVALID SCENARIOS:\no             o\n/             /\n---o-------o--o--o----\n/       /\no       o\n\nINVALID SCENARIOS:\no          o\n\\       /\n----o--o--o------o--o--o----\n/        \\\no          o",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "lineA",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "lineB",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 256,
    "kind": "function",
    "name": "crossDown",
    "memberof": "core/strategy/utils.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/strategy/utils.ts~crossDown",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/strategy/utils.ts",
    "importStyle": "{crossDown}",
    "description": "Validates a negative crossover of lineA and lineB\n\nVALID SCENARIOS:\no       o\n\\       \\\n---o-------o--o--o----\n\\             \\\no             o\n\nINVALID SCENARIOS:\no          o\n\\       /\n----o--o--o------o--o--o----\n/        \\\no          o",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "lineA",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "lineB",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 257,
    "kind": "file",
    "name": "core/types/nanoidDictionary.d.ts",
    "content": "declare module \"nanoid-dictionary\" {\n    export const lowercase: string;\n    export const uppercase: string;\n    export const numbers: string;\n    export const nolookalikes: string;\n}\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/types/nanoidDictionary.d.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 258,
    "kind": "file",
    "name": "core/types/pair.ts",
    "content": "export type Pair = [string, string];\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/types/pair.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 259,
    "kind": "file",
    "name": "core/web/spawnServer.ts",
    "content": "import {fork} from \"child_process\";\nimport minimist from \"minimist\";\nimport process from \"process\";\nimport config from \"../../config\";\n\nconst argv = minimist(process.argv.slice(2));\n\nexport default () => {\n    const webServer = fork(`${__dirname}/webServer.js`, [], {\n        stdio: [\"ipc\"],\n        execArgv: argv.debug ? [`--inspect=${config.webServer.debugPort}`] : [],\n    });\n\n    webServer.stdout.pipe(process.stdout);\n\n    webServer.on(\"exit\", (code, signal) => {\n        console.log(\"WebServer script exit: \", {code, signal});\n    });\n\n    webServer.on(\"error\", msg => {\n        console.log(\"WebServer script error: \", msg);\n    });\n\n    /**\n     * Re-emit incoming messages as separate events\n     * This makes it easier to handle each event separately\n     */\n    webServer.on(\"message\", event => {\n        if (!event.type) {\n            throw new Error(\"Event type is not correct. Expecting: { type: string, payload: any }\");\n        }\n\n        webServer.emit(event.type, event.payload);\n    });\n\n    /**\n     * Kill webServer if the main process has stopped working..\n     */\n    process.on(\"exit\", () => webServer.kill());\n\n    return webServer;\n};\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/web/spawnServer.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 260,
    "kind": "variable",
    "name": "argv",
    "memberof": "core/web/spawnServer.ts",
    "static": true,
    "longname": "core/web/spawnServer.ts~argv",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/web/spawnServer.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 261,
    "kind": "function",
    "name": "spawnServer",
    "memberof": "core/web/spawnServer.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "core/web/spawnServer.ts~spawnServer",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/web/spawnServer.ts",
    "importStyle": "spawnServer",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "file",
    "name": "core/web/webServer.ts",
    "content": "import fs from \"fs\";\nimport http, {Server} from \"http\";\nimport process from \"process\";\nimport {connection, IMessage, request, server as WebSocketServer} from \"websocket\";\nimport config from \"../../config\";\nimport {actions} from \"./whitelist\";\n\n/**\n * The WebServer communicates with the dashboard for trading visualizations\n */\nclass WebServer {\n    private static PORT = config.webServer.port;\n    private client?: connection;\n    private readonly httpServer: Server;\n\n    private server: WebSocketServer;\n\n    /**\n     * Creates a new webserver\n     */\n    constructor() {\n        this.ipcReceive();\n        this.httpServer = http.createServer((req, resp) => {\n            console.log((new Date()) + \" Received request for \" + req.url);\n            resp.writeHead(404);\n            resp.end();\n        });\n\n        this.server = new WebSocketServer({httpServer: this.httpServer});\n    }\n\n    /**\n     * Initializes the WebSocketServer.\n     * -> starts to listen on a specified port\n     * -> accepts requests coming from a certain frontend.\n     */\n    start() {\n        this.httpServer.listen(WebServer.PORT, () => {\n            console.log(`WebServer listening on port: ${WebServer.PORT}`);\n            this.ipcSend({type: \"READY\"});\n        });\n\n        this.server.on(\"request\", (req: request) => {\n            // @TODO validate request, request.reject() if not valid\n\n            if (this.client) {\n                return console.error(\"Max 1 client allowed!\");\n            }\n\n            this.client = req.accept(\"echo-protocol\", req.origin);\n\n            console.log((new Date()) + \" Connection accepted.\");\n            this.client.on(\"message\", ({type, utf8Data}: IMessage) => {\n                if (type !== \"utf8\" || utf8Data === undefined) {\n                    return console.error(\"Incoming message is not correct\");\n                }\n\n                const msg = JSON.parse(utf8Data);\n                if (actions.indexOf(msg.type) > -1) this.ipcSend(msg);\n            });\n\n            this.client.on(\"close\", (reasonCode, description) => {\n                if (this.client) console.log(`Client ${this.client.remoteAddress} disconnected.`, reasonCode, description);\n                this.client = undefined;\n            });\n        });\n    }\n\n    /**\n     * Forward file content to frontend\n     * @param cacheFile\n     */\n    private forwardCacheFile(cacheFile: string) {\n        const fileContent = fs.readFileSync(cacheFile, \"utf8\");\n        if (this.client) this.client.sendUTF(fileContent);\n    }\n\n    /**\n     * Receives events coming from the trading bot\n     * -> forward incoming events to the WebSocketServer\n     */\n    private ipcReceive() {\n        process.on(\"message\", ({type, payload}) => {\n            if (!type) {\n                throw new Error(\"Event type is not correct. Expecting: { type: string, payload: any }\");\n            }\n\n            if (type === \"CANDLE_FILE\") {\n                return this.forwardCacheFile(payload);\n            }\n\n            // Send data if a client is connected.\n            if (this.client) this.client.sendUTF(JSON.stringify({type, payload}));\n        });\n    }\n\n    /**\n     * Notify trading bot about things that are going on in the frontend.\n     * -> forward requests coming from a web frontend\n     * -> notify when the server is initialized, new open connection, a closed connection, etc..\n     * -> only allow whitelisted actions\n     *\n     * @param msg\n     */\n    private ipcSend(msg: any) {\n        if (process.send !== undefined) process.send(msg);\n    }\n}\n\nprocess.on(\"uncaughtException\", err => {\n    fs.writeSync(1, `Caught exception: ${err}\\n`);\n});\n\nconst webServer = new WebServer();\nwebServer.start();\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/web/webServer.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 263,
    "kind": "class",
    "name": "WebServer",
    "memberof": "core/web/webServer.ts",
    "static": true,
    "longname": "core/web/webServer.ts~WebServer",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/web/webServer.ts",
    "importStyle": null,
    "description": "The WebServer communicates with the dashboard for trading visualizations",
    "lineNumber": 11,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 264,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "core/web/webServer.ts~WebServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#constructor",
    "access": "public",
    "description": "Creates a new webserver",
    "lineNumber": 17
  },
  {
    "__docId__": 265,
    "kind": "member",
    "name": "httpServer",
    "memberof": "core/web/webServer.ts~WebServer",
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#httpServer",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "member",
    "name": "server",
    "memberof": "core/web/webServer.ts~WebServer",
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#server",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "start",
    "memberof": "core/web/webServer.ts~WebServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#start",
    "access": "public",
    "description": "Initializes the WebSocketServer.\n-> starts to listen on a specified port\n-> accepts requests coming from a certain frontend.",
    "lineNumber": 37,
    "params": [],
    "return": null
  },
  {
    "__docId__": 268,
    "kind": "member",
    "name": "client",
    "memberof": "core/web/webServer.ts~WebServer",
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#client",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "forwardCacheFile",
    "memberof": "core/web/webServer.ts~WebServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#forwardCacheFile",
    "access": "public",
    "description": "Forward file content to frontend",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "cacheFile",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "ipcReceive",
    "memberof": "core/web/webServer.ts~WebServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#ipcReceive",
    "access": "public",
    "description": "Receives events coming from the trading bot\n-> forward incoming events to the WebSocketServer",
    "lineNumber": 82,
    "params": [],
    "return": null
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "ipcSend",
    "memberof": "core/web/webServer.ts~WebServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "core/web/webServer.ts~WebServer#ipcSend",
    "access": "public",
    "description": "Notify trading bot about things that are going on in the frontend.\n-> forward requests coming from a web frontend\n-> notify when the server is initialized, new open connection, a closed connection, etc..\n-> only allow whitelisted actions",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 273,
    "kind": "variable",
    "name": "webServer",
    "memberof": "core/web/webServer.ts",
    "static": true,
    "longname": "core/web/webServer.ts~webServer",
    "access": "public",
    "export": false,
    "importPath": "socktrader/core/web/webServer.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "type": {
      "types": [
        "core/web/webServer.ts~WebServer"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 274,
    "kind": "file",
    "name": "core/web/whitelist.ts",
    "content": "// allowed actions going from webserver to sockTrader\nexport const actions = [\"READY\", \"START_TRADING\"];\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/core/web/whitelist.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 275,
    "kind": "variable",
    "name": "actions",
    "memberof": "core/web/whitelist.ts",
    "static": true,
    "longname": "core/web/whitelist.ts~actions",
    "access": "public",
    "export": true,
    "importPath": "socktrader/core/web/whitelist.ts",
    "importStyle": "{actions}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    }
  },
  {
    "kind": "index",
    "content": "<p align=\"center\"><img width=\"150\" height=\"150\" src=\"https://raw.githubusercontent.com/SockTrader/SockTrader/master/docs/SockTraderLogo.png\" alt=\"SockTrader logo\" /></p>\n\n<h1 align=\"center\">SockTrader</h1>\n<p align=\"center\"><b>Cryptocurrency trading bot</b></p>\n\n<p align=\"center\">\n  <a href=\"https://www.gnu.org/licenses/gpl-3.0\"><img src=\"https://img.shields.io/badge/License-GPL%20v3-blue.svg\" alt=\"License: GPL v3\"></a>\n  <a href=\"https://codecov.io/gh/SockTrader/SockTrader\"><img src=\"https://codecov.io/gh/SockTrader/SockTrader/branch/master/graph/badge.svg\" /></a>\n  <a href=\"https://travis-ci.org/SockTrader/SockTrader\"><img src=\"https://travis-ci.org/SockTrader/SockTrader.svg?branch=master\" alt=\"Build status\"></a>\n  <a href=\"https://codeclimate.com/github/SockTrader/SockTrader/maintainability\"><img src=\"https://api.codeclimate.com/v1/badges/19589f9237d31ca9dcf6/maintainability\" /></a>\n  <a href=\"https://david-dm.org/SockTrader/SockTrader\"><img src=\"https://david-dm.org/SockTrader/SockTrader.svg\" alt=\"Dependencies\"></a>\n  <a href=\"https://github.com/SockTrader/SockTrader\"><img src=\"https://raw.githubusercontent.com/SockTrader/SockTrader/master/docs/badge.svg\" alt=\"Documentation\"></a>\n</p>\n\n<p align=\"center\"><b>🚧 Project is currently under development! 🚧</b></p>\n\n## Features\n\n- 🚀 Realtime super-fast websocket trading\n- 📈 50+ Technical indicators ([docs](https://github.com/anandanand84/technicalindicators))\n- 🌈 Written in typescript!\n- 🌿 Unit tested source code\n- 💎 Strategy testing with LIVE exchange data.\n- 🏡 Backtesting engine with local data.\n- More features soon..\n\n## Quick start\n\nClone project\n```bash\ngit clone https://github.com/SockTrader/SockTrader\n```\n\nInstall dependencies\n```bash\nnpm run install\n```\n\nRun bot!\n```bash\nnpm run compile\n```\n\n## Configuration\n\n**HitBTC is the only supported exchange**\n**More exchanges will follow soon..**\n  \nCopy credentials.json.dist to credentials.json and replace publicKey and secretKey with the exchange credentials.\n\n\n## Your own strategy?\n\nFirst you need to create an entry file `index.ts` to initialize the framework.\nExample:\n```typescript\n#!/usr/bin/env node\nimport HitBTC, {CandleInterval} from \"./core/exchanges/hitBTC\";\nimport SockTrader from \"./core/sockTrader\";\nimport MyStrategy from \"./strategies/myStrategy\";\n\n// noinspection TsLint\nconst credentials = require(\"../credentials.json\");\n\nconst sockTrader = new SockTrader();\nconst hitBTC = HitBTC.getInstance(credentials.publicKey, credentials.secretKey);\n\nsockTrader.addExchange(hitBTC);\nsockTrader.addStrategy({\n    strategy: MyStrategy,\n    pair: \"BTCUSD\",\n    interval: CandleInterval.FIVE_MINUTES,\n    exchange: hitBTC,\n});\n\n// Uncomment if you want to start the bot from the terminal.\n// Otherwise you would need the dashboard to start the application.\n// sockTrader.start();\n```\n\nAnd secondly create a strategy file: `src/strategies/myStrategy.ts`\nExample:\n```typescript\nimport {ICandle} from \"../core/candleCollection\";\nimport Orderbook from \"../core/orderbook\";\nimport BaseStrategy from \"../core/strategy\";\n\nexport default class MyStrategy extends BaseStrategy {\n\n    public notifyOrder(data: any): void {\n        // Will be called when the exchange confirms an order\n    }\n\n    public updateCandles(candleCollection: ICandle[]): void {\n        // Will be called on each new candle\n        this.buy(\"BTCUSD\", 1000, 10);\n        this.sell(\"BTCUSD\", 2000, 10);\n    }\n\n    public updateOrderbook(orderbook: Orderbook): void {\n        // Will be called on each exchange orderbook update\n    }\n}\n```\n\n\n# We need your help!\nWe're looking for extra contributors to give this project a well deserved boost.\n\n\n## DISCLAIMER\n    Using a trading bot does not mean guaranteed profit. \n    Also, trading crypto currency is considered high risk.\n    Losses are possible, which SockTrader cannot be held responsible for.\n",
    "longname": "/Users/woutercleymans/Webunit/SockTrader/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"socktrader\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Websocket based trading bot for cryptocurrencies\",\n  \"main\": \"src/index.ts\",\n  \"repository\": \"https://github.com/SockTrader/SockTrader\",\n  \"scripts\": {\n    \"test\": \"jest --coverage --ci --forceExit\",\n    \"dev\": \"cross-env NODE_ENV=dev nodemon -e ts --exec \\\"npm run compile && node ./build/index.js\\\"\",\n    \"compile\": \"tsc\",\n    \"compile-es5\": \"tsc --target \\\"ES5\\\"\",\n    \"docs\": \"esdoc\",\n    \"lint\": \"tslint --fix --project ./\",\n    \"pre-commit\": \"echo 'Pre-commit checks..' && exit 0\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"testEnvironment\": \"node\",\n    \"testPathIgnorePatterns\": [\n      \"<rootDir>/build/\",\n      \"<rootDir>/node_modules/\"\n    ],\n    \"collectCoverageFrom\": [\n      \"src/**/*.{ts}\"\n    ],\n    \"globals\": {\n      \"ts-jest\": {\n        \"diagnostics\": false\n      }\n    }\n  },\n  \"pre-commit\": [\n    \"pre-commit\",\n    \"lint\"\n  ],\n  \"authors\": [\n    \"wouter cleymans\",\n    \"thijs raets\"\n  ],\n  \"engines\": {\n    \"node\": \">=10.14.2\"\n  },\n  \"license\": \"GPL-3.0\",\n  \"nodemonConfig\": {\n    \"ignore\": [\n      \"logs/*\"\n    ],\n    \"delay\": \"2500\"\n  },\n  \"esdoc\": {\n    \"source\": \"./src/core\",\n    \"destination\": \"./docs\",\n    \"plugins\": [\n      {\n        \"name\": \"esdoc-typescript-plugin\",\n        \"option\": {\n          \"enable\": true\n        }\n      },\n      {\n        \"name\": \"esdoc-standard-plugin\",\n        \"option\": {\n          \"brand\": {\n            \"logo\": \"./docs/SockTraderLogo.png\",\n            \"title\": \"SockTrader\",\n            \"description\": \"Websocket based trading bot for cryptocurrencies\",\n            \"repository\": \"https://github.com/SockTrader/SockTrader\",\n            \"site\": \"https://socktrader.github.io/SockTrader/\"\n          },\n          \"test\": {\n            \"source\": \"./src/tests\",\n            \"interfaces\": [\"describe\", \"it\", \"context\", \"suite\", \"test\"],\n            \"includes\": [\"(spec|Spec|test|Test)\\\\.ts$\"],\n            \"excludes\": [\"\\\\.config\\\\.ts$\"]\n          }\n        }\n      },\n      {\n        \"name\": \"esdoc-node\"\n      },\n      {\n        \"name\": \"esdoc-ecmascript-proposal-plugin\",\n        \"option\": {\n          \"all\": true\n        }\n      }\n    ]\n  },\n  \"dependencies\": {\n    \"cron\": \"^1.5.0\",\n    \"cron-parser\": \"^2.6.0\",\n    \"data-forge\": \"^1.3.0\",\n    \"data-forge-fs\": \"0.0.3\",\n    \"data-forge-plot\": \"^0.1.11\",\n    \"decimal.js-light\": \"^2.4.1\",\n    \"lodash.reverse\": \"^4.0.1\",\n    \"lodash.sortby\": \"^4.7.0\",\n    \"lodash.uniqby\": \"^4.7.0\",\n    \"lodash.uniqwith\": \"^4.5.0\",\n    \"minimist\": \"^1.2.0\",\n    \"mkdirp\": \"^0.5.1\",\n    \"moment\": \"^2.22.2\",\n    \"nanoid\": \"^2.0.0\",\n    \"nanoid-dictionary\": \"^2.0.0\",\n    \"numeral\": \"^2.0.6\",\n    \"rimraf\": \"^2.6.3\",\n    \"technicalindicators\": \"^2.0.5\",\n    \"typescript\": \"^3.1.6\",\n    \"websocket\": \"^1.0.28\",\n    \"winston\": \"^3.1.0\"\n  },\n  \"devDependencies\": {\n    \"@types/chai\": \"^4.1.7\",\n    \"@types/cron\": \"^1.3.0\",\n    \"@types/jest\": \"^23.3.12\",\n    \"@types/lodash.reverse\": \"^4.0.4\",\n    \"@types/lodash.sortby\": \"^4.7.4\",\n    \"@types/lodash.uniqby\": \"^4.7.4\",\n    \"@types/lodash.uniqwith\": \"^4.5.4\",\n    \"@types/minimist\": \"^1.2.0\",\n    \"@types/mkdirp\": \"^0.5.2\",\n    \"@types/nanoid\": \"^1.2.0\",\n    \"@types/node\": \"^10.12.15\",\n    \"@types/numeral\": \"0.0.25\",\n    \"@types/rimraf\": \"^2.0.2\",\n    \"@types/sinon\": \"^7.0.2\",\n    \"@types/websocket\": \"0.0.40\",\n    \"chai\": \"^4.2.0\",\n    \"codecov\": \"^3.1.0\",\n    \"cross-env\": \"^5.2.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-node\": \"^1.0.3\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"esdoc-typescript-plugin\": \"^1.0.1\",\n    \"jest\": \"^23.6.0\",\n    \"pre-commit\": \"^1.2.2\",\n    \"sinon\": \"^7.1.1\",\n    \"source-map-support\": \"^0.5.9\",\n    \"ts-jest\": \"^23.10.5\",\n    \"ts-node\": \"^7.0.1\",\n    \"tslint\": \"^5.11.0\"\n  }\n}\n",
    "longname": "/Users/woutercleymans/Webunit/SockTrader/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 276,
    "kind": "testFile",
    "name": "tests/baseExchange.spec.ts",
    "content": "/* tslint:disable */\nimport {expect} from \"chai\";\nimport \"jest\";\nimport {mock, spy} from \"sinon\";\nimport BaseExchange from \"../core/exchanges/baseExchange\";\nimport {IOrder, OrderSide, OrderStatus, OrderTimeInForce, OrderType, ReportType} from \"../core/orderInterface\";\nimport Orderbook from \"../core/orderbook\";\nimport CandleCollection from \"../core/candleCollection\";\nimport moment from \"moment\";\nimport {Pair} from \"../core/types/pair\";\nimport {EventEmitter} from \"events\";\n// import generate from \"nanoid/generate\";\n\nconst pair: Pair = [\"BTC\", \"USD\"];\n\n// @ts-ignore\nclass MockExchange extends BaseExchange {\n    public constructor() {\n        super();\n    }\n}\n\n\nlet exc = new MockExchange();\nconst getReport = (): IOrder => ({\n    id: \"123\",\n    createdAt: moment(),\n    price: 10,\n    quantity: 0.5,\n    reportType: ReportType.NEW,\n    side: OrderSide.BUY,\n    status: OrderStatus.NEW,\n    pair: pair,\n    timeInForce: OrderTimeInForce.GOOD_TILL_CANCEL,\n    type: OrderType.LIMIT,\n    updatedAt: moment(),\n});\n\nconst getOrder = (): IOrder => ({\n    id: \"4559a45057ded19e04d715c4b40f7ddd\",\n    createdAt: moment(),\n    price: 0.001263,\n    quantity: 0.02,\n    reportType: ReportType.NEW,\n    side: OrderSide.BUY,\n    status: OrderStatus.NEW,\n    pair: pair,\n    timeInForce: OrderTimeInForce.GOOD_TILL_CANCEL,\n    type: OrderType.LIMIT,\n    updatedAt: moment(),\n});\n\n\nbeforeEach(() => {\n    exc = new MockExchange();\n});\n\ndescribe(\"generateOrderId\", () => {\n    test(\"Should generate a random order id\", () => {\n        const orderId = exc[\"generateOrderId\"](pair);\n        expect(orderId).to.be.a(\"string\");\n        expect(orderId).to.have.lengthOf(32);\n    });\n});\n\ndescribe(\"createOrder\", () => {\n    test(\"Should create a buy order\", () => {\n        const createOrder = spy(exc, \"createOrder\");\n        exc.buy(pair, 1, 10);\n        expect(createOrder.calledOnce).to.eq(true);\n        expect(createOrder.args[0]).to.deep.equal([[\"BTC\", \"USD\"], 1, 10, \"buy\"]);\n    });\n\n    test(\"Should create a sell order\", () => {\n        const createOrder = spy(exc, \"createOrder\" as any);\n        exc.sell(pair, 1, 10);\n        expect(createOrder.calledOnce).to.eq(true);\n        expect(createOrder.args[0]).to.deep.equal([[\"BTC\", \"USD\"], 1, 10, \"sell\"]);\n    });\n\n    // @TODO fix test, mock generateOrderId\n    test(\"Should put an order into progress when creating an order\", () => {\n        const setOrderInProgress = spy(exc, \"setOrderInProgress\" as any);\n        const orderId = exc[\"createOrder\"](pair, 1, 10, OrderSide.SELL);\n        expect(setOrderInProgress.calledOnce).to.eq(true);\n        // expect(exc[\"orderInProgress\"][orderId]).to.equal(true);\n    });\n});\n\n\ndescribe(\"setOrderInProgress\", () => {\n    test(\"Should put an order in/out of progress\", () => {\n        const id = \"ORDER_123\";\n        exc[\"setOrderInProgress\"](id, true);\n        expect(exc[\"orderInProgress\"][id]).to.equal(true);\n        exc[\"setOrderInProgress\"](id, false);\n        expect(exc[\"orderInProgress\"][id]).to.equal(undefined);\n    });\n});\n\n\ndescribe(\"getCandleCollection\", () => {\n    test(\"Should return a cached candle collection for a trading pair\", () => {\n        const interval = {code: \"M1\", cron: \"00 */1 * * * *\"};\n        const ob = exc.getCandleCollection(pair, interval, () => {\n        });\n        expect(ob).to.be.an.instanceof(CandleCollection);\n        expect(ob).to.not.be.equal(new CandleCollection(interval));\n\n        const ob2 = exc.getCandleCollection(pair, interval, () => {\n        });\n        expect(ob).to.be.equal(ob2);\n    });\n});\n\n\ndescribe(\"onReport\", () => {\n    test(\"Should track all order changes\", () => {\n        const addOrder = spy(exc, \"addOrder\" as any);\n        const removeOrder = spy(exc, \"removeOrder\" as any);\n        const report = getReport();\n        exc.onReport({...report, reportType: ReportType.NEW});\n        expect(addOrder.calledOnce).to.eq(true);\n\n        exc.onReport({\n            ...report,\n            reportType: ReportType.REPLACED,\n            originalId: \"123\",\n            id: \"321\",\n        });\n        expect(removeOrder.calledOnce).to.eq(true);\n        expect(addOrder.calledTwice).to.eq(true);\n\n        exc.onReport({...report, reportType: ReportType.TRADE, status: OrderStatus.FILLED});\n        expect(removeOrder.calledTwice).to.eq(true);\n\n        exc.onReport({...report, reportType: ReportType.CANCELED});\n        expect(removeOrder.calledThrice).to.eq(true);\n\n        exc.onReport({...report, reportType: ReportType.EXPIRED});\n        expect(removeOrder.callCount).to.eq(4);\n\n        exc.onReport({...report, reportType: ReportType.SUSPENDED});\n        expect(removeOrder.callCount).to.eq(5);\n    });\n});\n\n\ndescribe(\"connect\", () => {\n    test(\"Should connect via a websocket connection string\", () => {\n        const spyOn = spy(exc[\"socketClient\"], \"on\");\n        const spyConnect = spy(exc[\"socketClient\"], \"connect\");\n\n        exc.connect(\"wss://my.fake.socket\");\n\n        expect(spyOn.args[0][0]).to.equal(\"connectFailed\");\n        expect(spyOn.args[1][0]).to.equal(\"connect\");\n        expect(spyConnect.args[0]).to.deep.equal([\"wss://my.fake.socket\"]);\n    });\n});\n\n\ndescribe(\"destroy\", () => {\n    test(\"Should remove all event listeners once the exchange is destroyed\", () => {\n        // This test should prevent memory leaks in an exchange.\n        const spyRemoveListeners = spy(exc, \"removeAllListeners\");\n\n        exc.destroy();\n\n        expect(exc).to.be.an.instanceof(EventEmitter);\n        expect(spyRemoveListeners.calledOnce).to.eq(true);\n    });\n});\n\n\ndescribe(\"connection\", () => {\n    test(\"Should send messages over a socket connection\", () => {\n        expect(() => exc.send(\"test_method\", {param1: \"param1\", param2: \"param2\"}))\n            .to.throw(\"First connect to the exchange before sending instructions..\");\n\n        const connection = {send: () => null};\n        const mockConnection = mock(connection);\n        exc[\"connection\"] = connection as any;\n        const result = JSON.stringify({\"method\": \"test\", \"params\": {\"param1\": \"1\", \"param2\": \"2\"}, \"id\": \"test\"});\n        mockConnection.expects(\"send\").once().withArgs(result);\n\n        exc.send(\"test\", {param1: \"1\", param2: \"2\"});\n        mockConnection.verify();\n    });\n});\n\n\ndescribe(\"addOrder\", () => {\n    test(\"Should store all open orders\", () => {\n        // const exc = new HtestBTC();\n        const order = getOrder();\n\n        expect(exc.getOpenOrders()).to.deep.eq([]);\n\n        exc[\"addOrder\"](order);\n        expect(exc.getOpenOrders()).to.deep.eq([order]);\n    });\n});\n\n\ndescribe(\"generateOrderId\", () => {\n    test(\"Should generate new order id's\", () => {\n        expect(exc.generateOrderId(pair).length).to.be.equal(32);\n        expect(exc.generateOrderId(pair)).to.be.an(\"string\");\n    });\n});\n\n\ndescribe(\"isAdjustingOrderAllowed\", () => {\n    test(\"Should verify if an order can be adjusted\", () => {\n        const order = getOrder();\n\n        expect(exc[\"isAdjustingOrderAllowed\"](order, 0.002, 0.02)).to.equal(true);\n        expect(exc[\"isAdjustingOrderAllowed\"](order, 0.002, 0.02)).to.equal(false);\n\n        exc[\"orderInProgress\"] = {};\n        expect(exc[\"isAdjustingOrderAllowed\"](order, 0.001263, 0.02)).to.equal(false);\n    });\n});\n\n\ndescribe(\"getOrderbook\", () => {\n    test(\"Should get singleton exchange orderbook\", () => {\n        const symbol = pair.join(\"\");\n\n        // No configuration given\n        expect(() => exc.getOrderbook(pair)).to.throw(\"No configuration found for pair: \\\"BTCUSD\\\"\");\n\n        exc.currencies[symbol] = {id: pair, quantityIncrement: 10, tickSize: 0.000001};\n\n        // Returns a new empty orderbook\n        const orderbook = exc.getOrderbook(pair);\n        expect(orderbook).to.deep.equal({pair, precision: 6, ask: [], bid: []});\n        expect(orderbook).to.be.an.instanceof(Orderbook);\n        expect(exc[\"orderbooks\"][symbol]).to.equal(orderbook);\n\n        expect(orderbook).to.not.equal(new Orderbook(pair, 6));\n\n        const orderbook2 = exc.getOrderbook(pair);\n        expect(orderbook2).to.equal(orderbook);\n    });\n});",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/tests/baseExchange.spec.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 277,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe0",
    "access": null,
    "description": "generateOrderId",
    "lineNumber": 55
  },
  {
    "__docId__": 278,
    "kind": "test",
    "name": "test1",
    "testId": 1,
    "memberof": "tests/baseExchange.spec.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe0.test1",
    "access": null,
    "description": "Should generate a random order id",
    "lineNumber": 56
  },
  {
    "__docId__": 279,
    "kind": "test",
    "name": "describe2",
    "testId": 2,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe2",
    "access": null,
    "description": "createOrder",
    "lineNumber": 62
  },
  {
    "__docId__": 280,
    "kind": "test",
    "name": "test3",
    "testId": 3,
    "memberof": "tests/baseExchange.spec.ts~describe2",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe2.test3",
    "access": null,
    "description": "Should create a buy order",
    "lineNumber": 63
  },
  {
    "__docId__": 281,
    "kind": "test",
    "name": "test4",
    "testId": 4,
    "memberof": "tests/baseExchange.spec.ts~describe2",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe2.test4",
    "access": null,
    "description": "Should create a sell order",
    "lineNumber": 69
  },
  {
    "__docId__": 282,
    "kind": "test",
    "name": "test5",
    "testId": 5,
    "memberof": "tests/baseExchange.spec.ts~describe2",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe2.test5",
    "access": null,
    "description": "Should put an order into progress when creating an order",
    "lineNumber": 76
  },
  {
    "__docId__": 283,
    "kind": "test",
    "name": "describe6",
    "testId": 6,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe6",
    "access": null,
    "description": "setOrderInProgress",
    "lineNumber": 83
  },
  {
    "__docId__": 284,
    "kind": "test",
    "name": "test7",
    "testId": 7,
    "memberof": "tests/baseExchange.spec.ts~describe6",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe6.test7",
    "access": null,
    "description": "Should put an order in/out of progress",
    "lineNumber": 84
  },
  {
    "__docId__": 285,
    "kind": "test",
    "name": "describe8",
    "testId": 8,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe8",
    "access": null,
    "description": "getCandleCollection",
    "lineNumber": 92
  },
  {
    "__docId__": 286,
    "kind": "test",
    "name": "test9",
    "testId": 9,
    "memberof": "tests/baseExchange.spec.ts~describe8",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe8.test9",
    "access": null,
    "description": "Should return a cached candle collection for a trading pair",
    "lineNumber": 93
  },
  {
    "__docId__": 287,
    "kind": "test",
    "name": "describe10",
    "testId": 10,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe10",
    "access": null,
    "description": "onReport",
    "lineNumber": 104
  },
  {
    "__docId__": 288,
    "kind": "test",
    "name": "test11",
    "testId": 11,
    "memberof": "tests/baseExchange.spec.ts~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe10.test11",
    "access": null,
    "description": "Should track all order changes",
    "lineNumber": 105
  },
  {
    "__docId__": 289,
    "kind": "test",
    "name": "describe12",
    "testId": 12,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe12",
    "access": null,
    "description": "connect",
    "lineNumber": 129
  },
  {
    "__docId__": 290,
    "kind": "test",
    "name": "test13",
    "testId": 13,
    "memberof": "tests/baseExchange.spec.ts~describe12",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe12.test13",
    "access": null,
    "description": "Should connect via a websocket connection string",
    "lineNumber": 130
  },
  {
    "__docId__": 291,
    "kind": "test",
    "name": "describe14",
    "testId": 14,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe14",
    "access": null,
    "description": "destroy",
    "lineNumber": 139
  },
  {
    "__docId__": 292,
    "kind": "test",
    "name": "test15",
    "testId": 15,
    "memberof": "tests/baseExchange.spec.ts~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe14.test15",
    "access": null,
    "description": "Should remove all event listeners once the exchange is destroyed",
    "lineNumber": 140
  },
  {
    "__docId__": 293,
    "kind": "test",
    "name": "describe16",
    "testId": 16,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe16",
    "access": null,
    "description": "connection",
    "lineNumber": 148
  },
  {
    "__docId__": 294,
    "kind": "test",
    "name": "test17",
    "testId": 17,
    "memberof": "tests/baseExchange.spec.ts~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe16.test17",
    "access": null,
    "description": "Should send messages over a socket connection",
    "lineNumber": 149
  },
  {
    "__docId__": 295,
    "kind": "test",
    "name": "describe18",
    "testId": 18,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe18",
    "access": null,
    "description": "addOrder",
    "lineNumber": 161
  },
  {
    "__docId__": 296,
    "kind": "test",
    "name": "test19",
    "testId": 19,
    "memberof": "tests/baseExchange.spec.ts~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe18.test19",
    "access": null,
    "description": "Should store all open orders",
    "lineNumber": 162
  },
  {
    "__docId__": 297,
    "kind": "test",
    "name": "describe20",
    "testId": 20,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe20",
    "access": null,
    "description": "generateOrderId",
    "lineNumber": 170
  },
  {
    "__docId__": 298,
    "kind": "test",
    "name": "test21",
    "testId": 21,
    "memberof": "tests/baseExchange.spec.ts~describe20",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe20.test21",
    "access": null,
    "description": "Should generate new order id's",
    "lineNumber": 171
  },
  {
    "__docId__": 299,
    "kind": "test",
    "name": "describe22",
    "testId": 22,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe22",
    "access": null,
    "description": "isAdjustingOrderAllowed",
    "lineNumber": 176
  },
  {
    "__docId__": 300,
    "kind": "test",
    "name": "test23",
    "testId": 23,
    "memberof": "tests/baseExchange.spec.ts~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe22.test23",
    "access": null,
    "description": "Should verify if an order can be adjusted",
    "lineNumber": 177
  },
  {
    "__docId__": 301,
    "kind": "test",
    "name": "describe24",
    "testId": 24,
    "memberof": "tests/baseExchange.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe24",
    "access": null,
    "description": "getOrderbook",
    "lineNumber": 185
  },
  {
    "__docId__": 302,
    "kind": "test",
    "name": "test25",
    "testId": 25,
    "memberof": "tests/baseExchange.spec.ts~describe24",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseExchange.spec.ts~describe24.test25",
    "access": null,
    "description": "Should get singleton exchange orderbook",
    "lineNumber": 186
  },
  {
    "__docId__": 303,
    "kind": "testFile",
    "name": "tests/baseStrategy.spec.ts",
    "content": "/* tslint:disable */\nimport {expect} from \"chai\";\nimport 'jest';\nimport BaseStrategy from \"../core/strategy/baseStrategy\";\nimport {stub} from \"sinon\";\nimport {IOrder, OrderSide} from \"../core/orderInterface\";\n\nclass MyStrategy extends BaseStrategy {\n}\n\n// @ts-ignore\nconst strategy = new MyStrategy();\nlet emit = null;\n\ndescribe(\"BaseStrategy\", () => {\n\n    beforeEach(() => {\n        emit = stub(strategy, \"emit\");\n    });\n\n    afterEach(() => {\n        emit.restore();\n    });\n\n    it(\"Should throw when notifyOrder is not implemented\", () => {\n        expect(strategy.notifyOrder).to.throw(\"Implement method: notifyOrder\");\n    });\n\n    it(\"Should throw when updateCandles is not implemented\", () => {\n        expect(strategy.updateCandles).to.throw(\"Implement method: updateCandles\");\n    });\n\n    it(\"Should throw when updateOrderbook is not implemented\", () => {\n        expect(strategy.updateOrderbook).to.throw(\"Implement method: updateOrderbook\");\n    });\n\n    it(\"Should emit adjustOrder event\", () => {\n        strategy.adjust({side: OrderSide.BUY} as IOrder, 10, 1);\n\n        // console.log(emit);\n        expect(emit.calledOnce).to.equal(true);\n        expect(emit.args[0]).to.deep.equal([\"app.adjustOrder\", {\n            order: {\n                side: \"buy\",\n            },\n            price: 10,\n            qty: 1,\n        }]);\n    });\n\n    it(\"Should emit buy signal\", () => {\n        strategy.buy(\"BTCUSD\", 10, 1);\n\n        // console.log(emit);\n        expect(emit.calledOnce).to.equal(true);\n        expect(emit.args[0]).to.deep.equal([\"app.signal\", {\n            price: 10,\n            qty: 1,\n            side: \"buy\",\n            symbol: \"BTCUSD\"\n        }]);\n    });\n\n    it(\"Should emit sell signal\", () => {\n        strategy.sell(\"BTCUSD\", 10, 1);\n\n        // console.log(emit);\n        expect(emit.calledOnce).to.equal(true);\n        expect(emit.args[0]).to.deep.equal([\"app.signal\", {\n            price: 10,\n            qty: 1,\n            side: \"sell\",\n            symbol: \"BTCUSD\"\n        }]);\n    });\n});\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/tests/baseStrategy.spec.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 304,
    "kind": "test",
    "name": "describe26",
    "testId": 26,
    "memberof": "tests/baseStrategy.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/baseStrategy.spec.ts~describe26",
    "access": null,
    "description": "BaseStrategy",
    "lineNumber": 18
  },
  {
    "__docId__": 305,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "tests/baseStrategy.spec.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseStrategy.spec.ts~describe26.it27",
    "access": null,
    "description": "Should throw when notifyOrder is not implemented",
    "lineNumber": 25
  },
  {
    "__docId__": 306,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "tests/baseStrategy.spec.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseStrategy.spec.ts~describe26.it28",
    "access": null,
    "description": "Should throw when updateCandles is not implemented",
    "lineNumber": 28
  },
  {
    "__docId__": 307,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "tests/baseStrategy.spec.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseStrategy.spec.ts~describe26.it29",
    "access": null,
    "description": "Should throw when updateOrderbook is not implemented",
    "lineNumber": 31
  },
  {
    "__docId__": 308,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "tests/baseStrategy.spec.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseStrategy.spec.ts~describe26.it30",
    "access": null,
    "description": "Should emit adjustOrder event",
    "lineNumber": 34
  },
  {
    "__docId__": 309,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "tests/baseStrategy.spec.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseStrategy.spec.ts~describe26.it31",
    "access": null,
    "description": "Should emit buy signal",
    "lineNumber": 46
  },
  {
    "__docId__": 310,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "tests/baseStrategy.spec.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "tests/baseStrategy.spec.ts~describe26.it32",
    "access": null,
    "description": "Should emit sell signal",
    "lineNumber": 57
  },
  {
    "__docId__": 311,
    "kind": "testFile",
    "name": "tests/candleCollection.spec.ts",
    "content": "/* tslint:disable */\nimport {expect} from 'chai';\nimport 'jest';\nimport sinon from 'sinon';\n\nimport CandleCollection, {ICandle} from \"../core/candleCollection\";\nimport moment, {Moment} from 'moment';\n\nconst start = moment().seconds(0).millisecond(0).subtract(7, \"minutes\");\nconst convertTimestamp = (candles) => candles.map(c => ({...c, timestamp: c.timestamp.toArray()}));\nconst getTime = (start: Moment, action = '+', minutes = 0): Moment => {\n    const method = (action === '+') ? 'add' : 'subtract';\n    return start.clone()[method](minutes, 'minutes');\n};\n\ndescribe('CandleCollection', () => {\n\n    it('Should sort all candles, with the latest candle first and the last candle last', () => {\n        const cc = new CandleCollection({code: 'M1', cron: \"00 */1 * * * *\"}, false);\n        const candles = cc.sort([\n            {open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: start.clone()},\n            {open: 2, high: 4, low: 2, close: 3, volume: 10, timestamp: start.clone().add(5, \"minutes\")},\n            {open: 1.5, high: 3, low: 1, close: 2, volume: 5, timestamp: start.clone().add(1, \"day\")},\n        ]);\n\n        expect(candles).to.deep.equal([\n            {open: 1.5, high: 3, low: 1, close: 2, volume: 5, timestamp: start.clone().add(1, \"day\")},\n            {open: 2, high: 4, low: 2, close: 3, volume: 10, timestamp: start.clone().add(5, \"minutes\")},\n            {open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: start.clone()},\n        ]);\n    });\n\n    it('Should fill all candle gaps until last interval occurrence before current time', () => {\n        const cc = new CandleCollection({code: 'M1', cron: \"00 */1 * * * *\"}, false);\n        cc.on(\"update\", (candles: ICandle[]) => {\n            expect(convertTimestamp(candles)).to.deep.equal([\n                {open: 3, high: 3, low: 3, close: 3, volume: 0, timestamp: getTime(start, '+', 7).toArray()},\n                {open: 3, high: 3, low: 3, close: 3, volume: 0, timestamp: getTime(start, '+', 6).toArray()},\n                {open: 2, high: 4, low: 2, close: 3, volume: 10, timestamp: getTime(start, '+', 5).toArray()},\n                {open: 2, high: 2, low: 2, close: 2, volume: 0, timestamp: getTime(start, '+', 4).toArray()},\n                {open: 2, high: 2, low: 2, close: 2, volume: 0, timestamp: getTime(start, '+', 3).toArray()},\n                {open: 2, high: 2, low: 2, close: 2, volume: 0, timestamp: getTime(start, '+', 2).toArray()},\n                {open: 1.5, high: 3, low: 1, close: 2, volume: 5, timestamp: getTime(start, '+', 1).toArray()},\n                {open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: getTime(start, '+').toArray()},\n            ]);\n        });\n\n        cc.set([\n            {open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: start.clone()},\n            {open: 2, high: 4, low: 2, close: 3, volume: 10, timestamp: start.clone().add(5, \"minutes\")},\n            {open: 1.5, high: 3, low: 1, close: 2, volume: 5, timestamp: start.clone().add(1, \"minutes\")},\n        ]);\n    });\n\n    it('Should fill all candle gaps until retention period is met', () => {\n        const cc = new CandleCollection({code: 'M1', cron: \"00 */1 * * * *\"}, false, 3);\n        cc.on(\"update\", (candles: ICandle[]) => {\n            expect(convertTimestamp(candles)).to.deep.equal([\n                {open: 3, high: 3, low: 3, close: 3, volume: 0, timestamp: getTime(start, '+', 7).toArray()},\n                {open: 3, high: 3, low: 3, close: 3, volume: 0, timestamp: getTime(start, '+', 6).toArray()},\n                {open: 2, high: 4, low: 2, close: 3, volume: 10, timestamp: getTime(start, '+', 5).toArray()},\n            ]);\n        });\n\n        cc.set([\n            {open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: start.clone()},\n            {open: 2, high: 4, low: 2, close: 3, volume: 10, timestamp: start.clone().add(5, \"minutes\")},\n            {open: 1.5, high: 3, low: 1, close: 2, volume: 5, timestamp: start.clone().add(1, \"minutes\")},\n        ]);\n    });\n\n    it('Should automatically generate new candles', () => {\n        const start = moment().seconds(0).millisecond(0);\n        const clock = sinon.useFakeTimers(new Date());\n        const results = [];\n\n        const cc = new CandleCollection({code: 'M1', cron: \"00 */1 * * * *\"}, true);\n        cc.on(\"update\", (candles: ICandle[]) => results.push(convertTimestamp(candles)));\n\n        // Generate new empty candle\n        clock.tick('01:00');\n\n        // Overwrite previous candles by using \"set\"\n        cc.set([{open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: start.clone().add(1, 'minutes')}]);\n\n        // Generate a new candle based on the previous one\n        clock.tick('01:00');\n\n        cc.stop();\n        expect(results).to.deep.equal([\n            [\n                {open: 0, high: 0, low: 0, close: 0, volume: 0, timestamp: getTime(start, '+', 1).toArray()}\n            ],\n            [\n                {open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: getTime(start, '+', 1).toArray()},\n            ],\n            [\n                {open: 1.5, high: 1.5, low: 1.5, close: 1.5, volume: 0, timestamp: getTime(start, '+', 2).toArray()},\n                {open: 1, high: 2, low: 0, close: 1.5, volume: 1, timestamp: getTime(start, '+', 1).toArray()},\n            ]\n        ]);\n        clock.restore();\n    });\n\n    it('Should update the collection', () => {\n        const start = moment().seconds(0).millisecond(0);\n        const results = [];\n\n        const cc = new CandleCollection({code: 'M1', cron: \"00 */1 * * * *\"}, false);\n        cc.on(\"update\", (candles: ICandle[]) => results.push(convertTimestamp(candles)));\n\n        cc.set([{open: 1, high: 2, low: 1, close: 1.5, volume: 1, timestamp: getTime(start, '-', 1)}]);\n        cc.update([{open: 1, high: 3, low: 0, close: 3, volume: 2, timestamp: getTime(start, '+', 1)}]);\n        cc.update([{open: 1, high: 4, low: 0, close: 3.5, volume: 3, timestamp: getTime(start, '+', 1)}]);\n\n        expect(results).to.deep.equal([\n            [\n                {open: 1.5, high: 1.5, low: 1.5, close: 1.5, volume: 0, timestamp: getTime(start).toArray()},\n                {open: 1, high: 2, low: 1, close: 1.5, volume: 1, timestamp: getTime(start, '-', 1).toArray()},\n            ],\n            [\n                {open: 1, high: 3, low: 0, close: 3, volume: 2, timestamp: getTime(start, '+', 1).toArray()},\n                {open: 1.5, high: 1.5, low: 1.5, close: 1.5, volume: 0, timestamp: getTime(start).toArray()},\n                {open: 1, high: 2, low: 1, close: 1.5, volume: 1, timestamp: getTime(start, '-', 1).toArray()},\n            ],\n            [\n                {open: 1, high: 4, low: 0, close: 3.5, volume: 3, timestamp: getTime(start, '+', 1).toArray()},\n                {open: 1.5, high: 1.5, low: 1.5, close: 1.5, volume: 0, timestamp: getTime(start).toArray()},\n                {open: 1, high: 2, low: 1, close: 1.5, volume: 1, timestamp: getTime(start, '-', 1).toArray()},\n            ],\n        ]);\n    });\n\n    it('Should remove oldest candle when retention period is met', () => {\n        const start = moment().seconds(0).millisecond(0);\n        const results = [];\n\n        // @TODO fix bug when retentionPeriod = 1\n        const cc = new CandleCollection({code: 'M1', cron: \"00 */1 * * * *\"}, false, 2);\n        cc.on(\"update\", (candles: ICandle[]) => results.push(convertTimestamp(candles)));\n\n        cc.set([{open: 1, high: 2, low: 1, close: 1.5, volume: 1, timestamp: getTime(start, '-', 1)}]);\n        cc.update([{open: 1, high: 3, low: 0, close: 3, volume: 2, timestamp: getTime(start, '+', 1)}]);\n        cc.update([{open: 3, high: 4, low: 2, close: 3.5, volume: 1, timestamp: getTime(start, '+', 2)}]);\n\n        expect(results).to.deep.equal([\n            [\n                {open: 1.5, high: 1.5, low: 1.5, close: 1.5, volume: 0, timestamp: getTime(start).toArray()},\n                {open: 1, high: 2, low: 1, close: 1.5, volume: 1, timestamp: getTime(start, '-', 1).toArray()},\n            ],\n            [\n                {open: 1, high: 3, low: 0, close: 3, volume: 2, timestamp: getTime(start, '+', 1).toArray()},\n                {open: 1.5, high: 1.5, low: 1.5, close: 1.5, volume: 0, timestamp: getTime(start).toArray()},\n            ],\n            [\n                {open: 3, high: 4, low: 2, close: 3.5, volume: 1, timestamp: getTime(start, '+', 2).toArray()},\n                {open: 1, high: 3, low: 0, close: 3, volume: 2, timestamp: getTime(start, '+', 1).toArray()},\n            ],\n        ]);\n    });\n});",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/tests/candleCollection.spec.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 312,
    "kind": "test",
    "name": "describe33",
    "testId": 33,
    "memberof": "tests/candleCollection.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/candleCollection.spec.ts~describe33",
    "access": null,
    "description": "CandleCollection",
    "lineNumber": 13
  },
  {
    "__docId__": 313,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "tests/candleCollection.spec.ts~describe33",
    "testDepth": 1,
    "static": true,
    "longname": "tests/candleCollection.spec.ts~describe33.it34",
    "access": null,
    "description": "Should sort all candles, with the latest candle first and the last candle last",
    "lineNumber": 14
  },
  {
    "__docId__": 314,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "tests/candleCollection.spec.ts~describe33",
    "testDepth": 1,
    "static": true,
    "longname": "tests/candleCollection.spec.ts~describe33.it35",
    "access": null,
    "description": "Should fill all candle gaps until last interval occurrence before current time",
    "lineNumber": 27
  },
  {
    "__docId__": 315,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "tests/candleCollection.spec.ts~describe33",
    "testDepth": 1,
    "static": true,
    "longname": "tests/candleCollection.spec.ts~describe33.it36",
    "access": null,
    "description": "Should fill all candle gaps until retention period is met",
    "lineNumber": 47
  },
  {
    "__docId__": 316,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "tests/candleCollection.spec.ts~describe33",
    "testDepth": 1,
    "static": true,
    "longname": "tests/candleCollection.spec.ts~describe33.it37",
    "access": null,
    "description": "Should automatically generate new candles",
    "lineNumber": 62
  },
  {
    "__docId__": 317,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "tests/candleCollection.spec.ts~describe33",
    "testDepth": 1,
    "static": true,
    "longname": "tests/candleCollection.spec.ts~describe33.it38",
    "access": null,
    "description": "Should update the collection",
    "lineNumber": 89
  },
  {
    "__docId__": 318,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "tests/candleCollection.spec.ts~describe33",
    "testDepth": 1,
    "static": true,
    "longname": "tests/candleCollection.spec.ts~describe33.it39",
    "access": null,
    "description": "Should remove oldest candle when retention period is met",
    "lineNumber": 114
  },
  {
    "__docId__": 319,
    "kind": "testFile",
    "name": "tests/hitBTC.spec.ts",
    "content": "/* tslint:disable */\nimport {expect} from \"chai\";\nimport 'jest';\nimport moment from \"moment\";\nimport {spy, stub} from \"sinon\";\nimport {IOrder, OrderSide} from \"../core/orderInterface\";\nimport HitBTC, {CandleInterval} from \"../core/exchanges/hitBTC\";\nimport CandleCollection, {ICandle} from \"../core/candleCollection\";\nimport {connection} from \"websocket\";\nimport {EventEmitter} from \"events\";\nimport {Pair} from \"../core/types/pair\";\nimport {IOrderbookData} from \"../core/exchanges/baseExchange\";\n\nconst pair: Pair = [\"BTC\", \"USD\"];\n\ndescribe(\"HitBTC\", () => {\n\n    let exchange = new HitBTC(\"PUB_123\", \"SEC_123\");\n    let send = null;\n\n    beforeEach(() => {\n        exchange = new HitBTC(\"PUB_123\", \"SEC_123\");\n        send = stub(exchange, \"send\");\n    });\n\n    afterEach(() => {\n        send.restore();\n    });\n\n    it(\"Should trigger the onCreate lifecycle event\", () => {\n        const onCreate = spy(HitBTC.prototype, \"onCreate\");\n        HitBTC.getInstance();\n        HitBTC.getInstance();\n\n        expect(onCreate.calledOnce).to.equal(true);\n        expect(onCreate.args[0]).to.deep.equal([]);\n        onCreate.restore();\n    });\n\n    it(\"Should subscribe to report events\", () => {\n        exchange.subscribeReports();\n        expect(send.args[0][0]).to.equal(\"subscribeReports\");\n    });\n\n    it(\"Should subscribe to orderbook events\", () => {\n        exchange.subscribeOrderbook(pair);\n        expect(send.args[0][0]).to.equal(\"subscribeOrderbook\");\n        expect(send.args[0][1]).to.deep.equal({symbol: pair});\n    });\n\n    it(\"Should subscribe to candle events\", () => {\n        exchange.subscribeCandles(pair, CandleInterval.FIVE_MINUTES);\n        expect(send.args[0][0]).to.equal(\"subscribeCandles\");\n        expect(send.args[0][1]).to.deep.equal({period: \"M5\", symbol: pair});\n    });\n\n    it(\"Should authenticate user on exchange\", () => {\n        exchange.login(\"PUB_123\", \"PRIV_123\");\n        expect(send.args[0][0]).to.equal(\"login\");\n        expect(send.args[0][1]).to.include({\"algo\": \"HS256\", \"pKey\": \"PUB_123\"});\n        expect(send.args[0][1]).to.include.all.keys(\"signature\", \"nonce\");\n    });\n\n    it(\"Should update a candle collection for a trading pair\", () => {\n        const getCollection = stub(exchange, \"getCandleCollection\");\n        const collection = new CandleCollection(CandleInterval.FIVE_MINUTES);\n        const set = spy(collection, \"set\");\n        getCollection.returns(collection);\n\n        const candles: ICandle[] = [{close: 1, high: 2, low: 0, open: 0, timestamp: moment(), volume: 10} as ICandle];\n\n        exchange.onUpdateCandles(pair, candles, CandleInterval.FIVE_MINUTES, \"set\");\n        expect(set.calledOnce).to.equal(true);\n        expect(set.args[0][0][0]).to.deep.include({close: 1, high: 2, low: 0, open: 0, volume: 10});\n        expect(set.args[0][0][0]).to.include.all.keys(\"timestamp\");\n\n        set.restore();\n        getCollection.restore();\n    });\n\n    it(\"Should emit candle events on an update\", () => {\n        const emit = spy(exchange, \"emit\");\n        const candles: ICandle[] = [{close: 1, high: 2, low: 0, open: 0, timestamp: moment(), volume: 10} as ICandle];\n        exchange.onUpdateCandles(pair, candles, CandleInterval.FIVE_MINUTES, \"set\");\n\n        expect(emit.calledOnce).to.equal(true);\n        expect(emit.args[0][0]).to.equal(\"app.updateCandles\");\n        expect(emit.args[0][1]).to.deep.equal(candles);\n\n        emit.restore();\n    });\n\n    it(\"Should update an in memory orderbook\", () => {\n        const emit = stub(exchange, \"emit\");\n        const getOrderbook = spy(exchange, \"getOrderbook\");\n        const ob: IOrderbookData = {\n            sequence: 1,\n            pair,\n            ask: [\n                {price: 0.0015, size: 100},\n            ],\n            bid: [\n                {price: 0.001391, size: 40},\n            ],\n        };\n\n        const {pair: symbol, ask, bid} = ob;\n        exchange.currencies[pair.join(\"\")] = {id: pair, quantityIncrement: 10, tickSize: 0.000001};\n\n        exchange.onUpdateOrderbook({...ob, sequence: -1}, \"setOrders\");\n        expect(getOrderbook.called).to.be.equal(false);\n\n        exchange.onUpdateOrderbook(ob, \"setOrders\");\n        expect(getOrderbook.called).to.be.equal(true);\n\n        expect(emit.args[0][0]).to.equal(\"app.updateOrderbook\");\n        expect(emit.args[0][1]).to.deep.equal({ask, bid, pair: symbol, precision: 6});\n        emit.restore();\n        getOrderbook.restore();\n    });\n\n    it(\"Should load currency configuration from the exchange\", () => {\n        exchange.loadCurrencies();\n        expect(send.calledOnce).to.equal(true);\n        expect(send.args[0]).to.deep.equal([\"getSymbols\"]);\n    });\n\n    it(\"Should cancel an order\", () => {\n        // @ts-ignore\n        const setOrderInProgress = stub(exchange, \"setOrderInProgress\");\n        exchange.cancelOrder({id: \"123\"} as IOrder);\n\n        expect(setOrderInProgress.calledOnce).to.equal(true);\n        expect(setOrderInProgress.args[0]).to.deep.equal([\"123\"]);\n        expect(send.calledOnce).to.equal(true);\n        expect(send.args[0]).to.deep.equal([\"cancelOrder\", {clientOrderId: \"123\"}]);\n\n        setOrderInProgress.restore();\n    });\n\n    it(\"Should adjust existing orders\", () => {\n        // @ts-ignore\n        const adjustAllowed = stub(exchange, \"isAdjustingOrderAllowed\");\n        adjustAllowed.returns(true);\n\n        exchange.adjustOrder({pair: pair, id: \"123\"} as IOrder, 0.002, 0.5);\n        expect(send.calledOnce).to.equal(true);\n        expect(send.args[0][0]).to.equal(\"cancelReplaceOrder\");\n        expect(send.args[0][1]).to.include({clientOrderId: \"123\", price: 0.002, quantity: 0.5, strictValidate: true});\n        expect(send.args[0][1]).to.include.all.keys(\"requestClientId\");\n\n        adjustAllowed.restore();\n    });\n\n    it(\"Should create a new order\", () => {\n        const orderId = exchange[\"createOrder\"](pair, 10, 1, OrderSide.BUY);\n\n        expect(send.calledOnce).to.equal(true);\n        expect(send.args[0][0]).to.equal(\"newOrder\");\n        expect(send.args[0][1].clientOrderId).to.equal(orderId);\n        expect(send.args[0][1]).to.contain({\n            price: 10,\n            quantity: 1,\n            side: \"buy\",\n            symbol: pair,\n            type: \"limit\",\n        });\n    });\n\n    it(\"Should initialize when exchange is connected\", () => {\n        const loadCurrencies = stub(exchange, \"loadCurrencies\");\n        const onReceive = stub(exchange.mapper, \"onReceive\");\n        const login = stub(exchange, \"login\");\n        const connection = new EventEmitter();\n\n        exchange[\"onConnect\"](connection as connection);\n\n        expect(loadCurrencies.calledOnce).to.be.equal(true);\n        expect(login.calledOnce).to.be.equal(true);\n        expect(login.args[0]).to.deep.equal([\"PUB_123\", \"SEC_123\"]);\n\n        connection.emit(\"message\", JSON.stringify({test: \"123\"}));\n\n        expect(onReceive.calledOnce).to.be.equal(true);\n        expect(onReceive.args[0][0]).to.equal(JSON.stringify({test: \"123\"}));\n\n        loadCurrencies.restore();\n        onReceive.restore();\n        login.restore();\n    });\n\n    it(\"Should connect\", () => {\n        // @ts-ignore\n        const connect = stub(exchange.__proto__.__proto__, \"connect\");\n\n        exchange.connect();\n        expect(connect.args[0]).to.deep.equal(['wss://api.hitbtc.com/api/2/ws']);\n    });\n});\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/tests/hitBTC.spec.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 320,
    "kind": "test",
    "name": "describe40",
    "testId": 40,
    "memberof": "tests/hitBTC.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40",
    "access": null,
    "description": "HitBTC",
    "lineNumber": 11
  },
  {
    "__docId__": 321,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it41",
    "access": null,
    "description": "Should trigger the onCreate lifecycle event",
    "lineNumber": 21
  },
  {
    "__docId__": 322,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it42",
    "access": null,
    "description": "Should subscribe to report events",
    "lineNumber": 29
  },
  {
    "__docId__": 323,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it43",
    "access": null,
    "description": "Should subscribe to orderbook events",
    "lineNumber": 33
  },
  {
    "__docId__": 324,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it44",
    "access": null,
    "description": "Should subscribe to candle events",
    "lineNumber": 38
  },
  {
    "__docId__": 325,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it45",
    "access": null,
    "description": "Should authenticate user on exchange",
    "lineNumber": 43
  },
  {
    "__docId__": 326,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it46",
    "access": null,
    "description": "Should update a candle collection for a trading pair",
    "lineNumber": 49
  },
  {
    "__docId__": 327,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it47",
    "access": null,
    "description": "Should emit candle events on an update",
    "lineNumber": 62
  },
  {
    "__docId__": 328,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it48",
    "access": null,
    "description": "Should update an in memory orderbook",
    "lineNumber": 71
  },
  {
    "__docId__": 329,
    "kind": "test",
    "name": "it49",
    "testId": 49,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it49",
    "access": null,
    "description": "Should load currency configuration from the exchange",
    "lineNumber": 95
  },
  {
    "__docId__": 330,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it50",
    "access": null,
    "description": "Should cancel an order",
    "lineNumber": 100
  },
  {
    "__docId__": 331,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it51",
    "access": null,
    "description": "Should adjust existing orders",
    "lineNumber": 110
  },
  {
    "__docId__": 332,
    "kind": "test",
    "name": "it52",
    "testId": 52,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it52",
    "access": null,
    "description": "Should create a new order",
    "lineNumber": 121
  },
  {
    "__docId__": 333,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it53",
    "access": null,
    "description": "Should initialize when exchange is connected",
    "lineNumber": 134
  },
  {
    "__docId__": 334,
    "kind": "test",
    "name": "it54",
    "testId": 54,
    "memberof": "tests/hitBTC.spec.ts~describe40",
    "testDepth": 1,
    "static": true,
    "longname": "tests/hitBTC.spec.ts~describe40.it54",
    "access": null,
    "description": "Should connect",
    "lineNumber": 150
  },
  {
    "__docId__": 335,
    "kind": "testFile",
    "name": "tests/orderbook.spec.ts",
    "content": "/* tslint:disable */\nimport {expect} from \"chai\";\nimport {spy} from 'sinon';\nimport 'jest';\nimport Orderbook, {Operator} from \"../core/orderbook\";\nimport {Pair} from \"../core/types/pair\";\n\nconst pair: Pair = [\"BTC\", \"ETH\"];\ndescribe('Orderbook', () => {\n    let ob = new Orderbook(pair, 8);\n    beforeEach(() => {\n        ob = new Orderbook(pair, 8);\n        ob.setOrders([\n            {price: 0.074819, size: 100},\n            {price: 0.074817, size: 100},\n            {price: 0.074834, size: 2500},\n        ], [\n            {price: 0.074940, size: 451},\n            {price: 0.074944, size: 2000},\n            {price: 0.074925, size: 100},\n        ]);\n    });\n\n    it(\"calculate the adjusted price\", () => {\n        expect(ob.getAdjustedPrice(2, Operator.MINUS, 1)).to.be.equal(1.99999999);\n        expect(ob.getAdjustedPrice(2, Operator.MINUS, 0.1)).to.be.equal(1.999999999);\n        expect(ob.getAdjustedPrice(0.1, Operator.MINUS, 1)).to.be.equal(0.09999999);\n\n        expect(ob.getAdjustedPrice(0.001263, Operator.MINUS, 1)).to.be.equal(0.00126299);\n        expect(ob.getAdjustedPrice(0.001263, Operator.MINUS, 2)).to.be.equal(0.00126298);\n        expect(ob.getAdjustedPrice(0.001263, Operator.MINUS, 3)).to.be.equal(0.00126297);\n\n        expect(ob.getAdjustedPrice(0.001263, Operator.MINUS, 0.1)).to.be.equal(0.001262999);\n    });\n\n    it(\"calculate bid and ask spread\", () => {\n        expect(Orderbook.getBidAskSpreadPerc(1, 2)).to.be.equal(1);\n        expect(Orderbook.getBidAskSpreadPerc(0.5, 2)).to.be.equal(3);\n        expect(Orderbook.getBidAskSpreadPerc(0.001391, 0.001500)).to.be.equal(0.07836089144500359);\n    });\n\n    it(\"calculate satoshi difference between two numbers\", () => {\n        expect(ob.getSatDiff(1, 2)).to.be.equal(100000000);\n        expect(ob.getSatDiff(0.1, 0.2)).to.be.equal(10000000);\n        expect(ob.getSatDiff(0.1, 0.25)).to.be.equal(15000000);\n        expect(ob.getSatDiff(0.25, 0.1)).to.be.equal(15000000);\n\n        expect(ob.getSatDiff(0.001263, 0.001265)).to.be.equal(200);\n        expect(ob.getSatDiff(0.001265, 0.001263)).to.be.equal(200);\n\n        expect(ob.getSatDiff(0.001265, 0.00127)).to.be.equal(500);\n        expect(ob.getSatDiff(0.00127, 0.001265)).to.be.equal(500);\n    });\n\n    it(\"Should set sorted orders in orderbook\", () => {\n        expect(ob.ask).to.deep.equal([\n            {\"price\": 0.074817, \"size\": 100},\n            {\"price\": 0.074819, \"size\": 100},\n            {\"price\": 0.074834, \"size\": 2500},\n        ]);\n        expect(ob.bid).to.deep.equal([\n            {\"price\": 0.074944, \"size\": 2000},\n            {\"price\": 0.074940, \"size\": 451},\n            {\"price\": 0.074925, \"size\": 100},\n        ]);\n    });\n\n    it(\"Should return a subset of the orderbook\", () => {\n        const ask = ob.getEntries(\"ask\", 1);\n        const bid = ob.getEntries(\"bid\", 1);\n        expect(ask).to.deep.equal([{\"price\": 0.074817, \"size\": 100}]);\n        expect(bid).to.deep.equal([{\"price\": 0.074944, \"size\": 2000}]);\n    });\n\n    it(\"Should be updatable with an increment\", () => {\n        const applyIncrement = spy(ob, \"applyIncrement\" as any);\n        ob.addIncrement([\n            {\"price\": 0.074834, \"size\": 100},\n            {\"price\": 0.074835, \"size\": 200},\n            {\"price\": 0.074817, \"size\": 0},\n            {\"price\": 0.074819, \"size\": 150},\n        ], [\n            {\"price\": 0.074944, \"size\": 100},\n            {\"price\": 0.074925, \"size\": 150},\n            {\"price\": 0.074940, \"size\": 0},\n            {\"price\": 0.074941, \"size\": 10},\n        ]);\n\n        expect(applyIncrement.calledTwice).to.eq(true);\n        expect(ob.ask).to.deep.equal([\n            {\"price\": 0.074819, \"size\": 150},\n            {\"price\": 0.074834, \"size\": 100},\n            {\"price\": 0.074835, \"size\": 200},\n        ]);\n        expect(ob.bid).to.deep.equal([\n            {\"price\": 0.074944, \"size\": 100},\n            {\"price\": 0.074941, \"size\": 10},\n            {\"price\": 0.074925, \"size\": 150},\n        ]);\n    });\n});\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/tests/orderbook.spec.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 336,
    "kind": "test",
    "name": "describe55",
    "testId": 55,
    "memberof": "tests/orderbook.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/orderbook.spec.ts~describe55",
    "access": null,
    "description": "Orderbook",
    "lineNumber": 7
  },
  {
    "__docId__": 337,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "tests/orderbook.spec.ts~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "tests/orderbook.spec.ts~describe55.it56",
    "access": null,
    "description": "calculate the adjusted price",
    "lineNumber": 21
  },
  {
    "__docId__": 338,
    "kind": "test",
    "name": "it57",
    "testId": 57,
    "memberof": "tests/orderbook.spec.ts~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "tests/orderbook.spec.ts~describe55.it57",
    "access": null,
    "description": "calculate bid and ask spread",
    "lineNumber": 30
  },
  {
    "__docId__": 339,
    "kind": "test",
    "name": "it58",
    "testId": 58,
    "memberof": "tests/orderbook.spec.ts~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "tests/orderbook.spec.ts~describe55.it58",
    "access": null,
    "description": "calculate satoshi difference between two numbers",
    "lineNumber": 35
  },
  {
    "__docId__": 340,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "tests/orderbook.spec.ts~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "tests/orderbook.spec.ts~describe55.it59",
    "access": null,
    "description": "Should set sorted orders in orderbook",
    "lineNumber": 45
  },
  {
    "__docId__": 341,
    "kind": "test",
    "name": "it60",
    "testId": 60,
    "memberof": "tests/orderbook.spec.ts~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "tests/orderbook.spec.ts~describe55.it60",
    "access": null,
    "description": "Should return a subset of the orderbook",
    "lineNumber": 57
  },
  {
    "__docId__": 342,
    "kind": "test",
    "name": "it61",
    "testId": 61,
    "memberof": "tests/orderbook.spec.ts~describe55",
    "testDepth": 1,
    "static": true,
    "longname": "tests/orderbook.spec.ts~describe55.it61",
    "access": null,
    "description": "Should be updatable with an increment",
    "lineNumber": 63
  },
  {
    "__docId__": 343,
    "kind": "testFile",
    "name": "tests/sockTrader.spec.ts",
    "content": "/* tslint:disable */\nimport SimpleMovingAverage from \"../strategies/simpleMovingAverage\";\nimport {IExchange} from \"../core/exchanges/exchangeInterface\";\nimport SockTrader from \"../core/sockTrader\";\nimport {CandleInterval, default as HitBTC} from \"../core/exchanges/hitBTC\";\nimport {Pair} from \"../core/types/pair\";\nimport objectContaining = jasmine.objectContaining;\n\nclass ConcreteSockTrader extends SockTrader {\n\n    addExchange(exchange: IExchange): this {\n        this.exchange = exchange;\n\n        return this;\n    }\n\n    getExchange(): IExchange {\n        return this.exchange;\n    }\n}\n\nconst hitBTC = new HitBTC(\"PUB_123\", \"SEC_123\");\nconst sockTrader = new ConcreteSockTrader({webServer: false});\nconst btcEthPair: Pair = [\"BTC\", \"ETH\"];\nconst btcCovPair: Pair = [\"BTC\", \"COV\"];\n\n\ndescribe(\"subscribeToExchangeEvents\", () => {\n    test(\"Should subscribe to orderbook once with 2 configs: same pair, different interval\", () => {\n        const mockSubscribeReports = jest.fn();\n        const mockSubscribeOrderbook = jest.fn();\n        const mockSubscribeCandles = jest.fn();\n\n        hitBTC.subscribeReports = mockSubscribeReports;\n        hitBTC.subscribeOrderbook = mockSubscribeOrderbook;\n        hitBTC.subscribeCandles = mockSubscribeCandles;\n\n        sockTrader.addExchange(hitBTC);\n        sockTrader.subscribeToExchangeEvents([{\n            strategy: SimpleMovingAverage,\n            pair: btcEthPair,\n            interval: CandleInterval.FIVE_MINUTES,\n        },\n            {\n                strategy: SimpleMovingAverage,\n                pair: btcEthPair,\n                interval: CandleInterval.FOUR_HOURS,\n            },\n        ]);\n        hitBTC.emit(\"ready\");\n\n        expect(mockSubscribeReports).toBeCalledTimes(1);\n        expect(mockSubscribeOrderbook).toBeCalledTimes(1);\n        expect(mockSubscribeOrderbook).toBeCalledWith(btcEthPair);\n        expect(mockSubscribeCandles).toBeCalledTimes(2);\n        expect(mockSubscribeCandles).toBeCalledWith(btcEthPair, CandleInterval.FIVE_MINUTES);\n        expect(mockSubscribeCandles).toBeCalledWith(btcEthPair, CandleInterval.FOUR_HOURS);\n\n        mockSubscribeReports.mockRestore();\n        mockSubscribeOrderbook.mockRestore();\n        mockSubscribeCandles.mockRestore();\n    });\n\n    test(\"Should subscribe to orderbook twice with 2 configs: different pair, same interval\", () => {\n        const mockSubscribeReports = jest.fn();\n        const mockSubscribeOrderbook = jest.fn();\n        const mockSubscribeCandles = jest.fn();\n\n        hitBTC.subscribeReports = mockSubscribeReports;\n        hitBTC.subscribeOrderbook = mockSubscribeOrderbook;\n        hitBTC.subscribeCandles = mockSubscribeCandles;\n\n        sockTrader.addExchange(hitBTC);\n\n        sockTrader.subscribeToExchangeEvents([{\n            strategy: SimpleMovingAverage,\n            pair: btcEthPair,\n            interval: CandleInterval.FIVE_MINUTES,\n        },\n            {\n                strategy: SimpleMovingAverage,\n                pair: btcCovPair,\n                interval: CandleInterval.FIVE_MINUTES,\n            },\n        ]);\n        hitBTC.emit(\"ready\");\n\n        expect(mockSubscribeReports).toBeCalledTimes(1);\n        expect(mockSubscribeOrderbook).toBeCalledTimes(2);\n        expect(mockSubscribeOrderbook).toBeCalledWith(btcEthPair);\n        expect(mockSubscribeOrderbook).toBeCalledWith(btcCovPair);\n        expect(mockSubscribeCandles).toBeCalledTimes(2);\n        expect(mockSubscribeCandles).toBeCalledWith(btcEthPair, CandleInterval.FIVE_MINUTES);\n        expect(mockSubscribeCandles).toBeCalledWith(btcCovPair, CandleInterval.FIVE_MINUTES);\n\n        mockSubscribeReports.mockRestore();\n        mockSubscribeOrderbook.mockRestore();\n        mockSubscribeCandles.mockRestore();\n    });\n\n    test(\"Should subscribe to orderbook/candles once with 2 configs: same pair, same interval\", () => {\n        const mockSubscribeReports = jest.fn();\n        const mockSubscribeOrderbook = jest.fn();\n        const mockSubscribeCandles = jest.fn();\n\n        hitBTC.subscribeReports = mockSubscribeReports;\n        hitBTC.subscribeOrderbook = mockSubscribeOrderbook;\n        hitBTC.subscribeCandles = mockSubscribeCandles;\n\n        sockTrader.addExchange(hitBTC);\n\n        sockTrader.subscribeToExchangeEvents([{\n            strategy: SimpleMovingAverage,\n            pair: btcEthPair,\n            interval: CandleInterval.FIVE_MINUTES,\n        },\n            {\n                strategy: SimpleMovingAverage,\n                pair: btcEthPair,\n                interval: CandleInterval.FIVE_MINUTES,\n            },\n        ]);\n        hitBTC.emit(\"ready\");\n\n        expect(mockSubscribeReports).toBeCalledTimes(1);\n        expect(mockSubscribeOrderbook).toBeCalledTimes(1);\n        expect(mockSubscribeOrderbook).toBeCalledWith(btcEthPair);\n        expect(mockSubscribeCandles).toBeCalledTimes(1);\n        expect(mockSubscribeCandles).toBeCalledWith(btcEthPair, CandleInterval.FIVE_MINUTES);\n\n        mockSubscribeReports.mockRestore();\n        mockSubscribeOrderbook.mockRestore();\n        mockSubscribeCandles.mockRestore();\n    });\n\n});\n\ndescribe(\"addExchange\", () => {\n    test(\"Should add exchange to socketTrader\", () => {\n        sockTrader.addExchange(hitBTC);\n        expect(sockTrader.getExchange()).toBe(hitBTC);\n    });\n});\n\ndescribe(\"bindExchangeToStrategy\", () => {\n    test(\"Should bind exchange events to strategy\", () => {\n        const mockOn = jest.fn();\n        hitBTC.on = mockOn;\n\n        sockTrader.addExchange(hitBTC);\n        sockTrader[\"bindExchangeToStrategy\"](new SimpleMovingAverage(btcEthPair, hitBTC));\n        expect(mockOn).toBeCalledWith(\"app.report\", expect.anything());\n        expect(mockOn).toBeCalledWith(\"app.updateOrderbook\", expect.anything());\n        expect(mockOn).toBeCalledWith(\"app.updateCandles\", expect.anything());\n    });\n});\n\ndescribe(\"bindStrategyToExchange\", () => {\n    test(\"Should bind strategy events to exchange\", () => {\n        const simpleMovingAverage: SimpleMovingAverage = new SimpleMovingAverage(btcEthPair, hitBTC);\n        const spyOn = jest.spyOn(simpleMovingAverage, \"on\");\n\n        sockTrader[\"bindStrategyToExchange\"](simpleMovingAverage);\n        expect(spyOn).toBeCalledWith(\"app.signal\", expect.anything());\n        expect(spyOn).toBeCalledWith(\"app.adjustOrder\", expect.anything());\n    });\n});\n\ndescribe(\"sendToWebServer\", () => {\n    test(\"Should broadcast payload to socket server\", () => {\n        const childSend = jest.fn();\n\n        // @ts-ignore\n        sockTrader[\"webServer\"] = {send: childSend};\n        sockTrader[\"sendToWebServer\"](\"type\",  \"payload\");\n        expect(childSend).toBeCalledWith(objectContaining({\n            type: \"type\",\n            payload: \"payload\"\n        }));\n    });\n});\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/tests/sockTrader.spec.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 344,
    "kind": "test",
    "name": "describe62",
    "testId": 62,
    "memberof": "tests/sockTrader.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe62",
    "access": null,
    "description": "subscribeToExchangeEvents",
    "lineNumber": 41
  },
  {
    "__docId__": 345,
    "kind": "test",
    "name": "test63",
    "testId": 63,
    "memberof": "tests/sockTrader.spec.ts~describe62",
    "testDepth": 1,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe62.test63",
    "access": null,
    "description": "Should subscribe to orderbook once with 2 configs: same pair, different interval",
    "lineNumber": 42
  },
  {
    "__docId__": 346,
    "kind": "test",
    "name": "test64",
    "testId": 64,
    "memberof": "tests/sockTrader.spec.ts~describe62",
    "testDepth": 1,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe62.test64",
    "access": null,
    "description": "Should subscribe to orderbook twice with 2 configs: different pair, same interval",
    "lineNumber": 72
  },
  {
    "__docId__": 347,
    "kind": "test",
    "name": "test65",
    "testId": 65,
    "memberof": "tests/sockTrader.spec.ts~describe62",
    "testDepth": 1,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe62.test65",
    "access": null,
    "description": "Should subscribe to orderbook/candles once with 2 configs: same pair, same interval",
    "lineNumber": 103
  },
  {
    "__docId__": 348,
    "kind": "test",
    "name": "describe66",
    "testId": 66,
    "memberof": "tests/sockTrader.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe66",
    "access": null,
    "description": "addExchange",
    "lineNumber": 133
  },
  {
    "__docId__": 349,
    "kind": "test",
    "name": "test67",
    "testId": 67,
    "memberof": "tests/sockTrader.spec.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe66.test67",
    "access": null,
    "description": "Should add exchange to socketTrader",
    "lineNumber": 134
  },
  {
    "__docId__": 350,
    "kind": "test",
    "name": "describe68",
    "testId": 68,
    "memberof": "tests/sockTrader.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe68",
    "access": null,
    "description": "bindExchangeToStrategy",
    "lineNumber": 139
  },
  {
    "__docId__": 351,
    "kind": "test",
    "name": "test69",
    "testId": 69,
    "memberof": "tests/sockTrader.spec.ts~describe68",
    "testDepth": 1,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe68.test69",
    "access": null,
    "description": "Should bind exchange events to strategy",
    "lineNumber": 140
  },
  {
    "__docId__": 352,
    "kind": "test",
    "name": "describe70",
    "testId": 70,
    "memberof": "tests/sockTrader.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe70",
    "access": null,
    "description": "bindStrategyToExchange",
    "lineNumber": 150
  },
  {
    "__docId__": 353,
    "kind": "test",
    "name": "test71",
    "testId": 71,
    "memberof": "tests/sockTrader.spec.ts~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe70.test71",
    "access": null,
    "description": "Should bind strategy events to exchange",
    "lineNumber": 151
  },
  {
    "__docId__": 354,
    "kind": "test",
    "name": "describe72",
    "testId": 72,
    "memberof": "tests/sockTrader.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe72",
    "access": null,
    "description": "sendToWebServer",
    "lineNumber": 159
  },
  {
    "__docId__": 355,
    "kind": "test",
    "name": "test73",
    "testId": 73,
    "memberof": "tests/sockTrader.spec.ts~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "tests/sockTrader.spec.ts~describe72.test73",
    "access": null,
    "description": "Should broadcast payload to socket server",
    "lineNumber": 160
  },
  {
    "__docId__": 356,
    "kind": "testFile",
    "name": "tests/utils.spec.ts",
    "content": "/* tslint:disable */\nimport 'jest';\nimport {crossDown, crossUp} from \"../core/strategy/utils\";\nimport {expect} from \"chai\";\n\ndescribe(\"Strategy utilities\", () => {\n\n    it(\"Should find a positive crossover\", () => {\n        expect(crossUp([10, 5, 0], [5, 5, 5])).to.eq(true);\n        expect(crossUp([10, 5, 5, 5, 0], [5, 5, 5, 5, 5])).to.eq(true);\n\n        expect(crossUp([undefined, 5, 0], [5, 5, undefined])).to.eq(false);\n\n        expect(crossUp([10, 5, 5], [5, 5, 5])).to.eq(false);\n        expect(crossUp([10, 5, 5, 10], [5, 5, 5, 5])).to.eq(false);\n\n        expect(crossUp([0, 5, 0], [5, 5, 5])).to.eq(false);\n        expect(crossUp([0, 5, 5, 5, 0], [5, 5, 5, 5, 5])).to.eq(false);\n    });\n\n    it(\"Should find a negative crossover\", () => {\n        expect(crossDown([0, 5, 10], [5, 5, 5])).to.eq(true);\n        expect(crossDown([0, 5, 5, 5, 10], [5, 5, 5, 5, 5])).to.eq(true);\n\n        expect(crossDown([undefined, 5, 10], [5, 5, undefined])).to.eq(false);\n\n        expect(crossDown([0, 5, 5], [5, 5, 5])).to.eq(false);\n        expect(crossDown([10, 5, 5, 10], [5, 5, 5, 5])).to.eq(false);\n\n        expect(crossDown([0, 5, 0], [5, 5, 5])).to.eq(false);\n        expect(crossDown([0, 5, 5, 5, 0], [5, 5, 5, 5, 5])).to.eq(false);\n    });\n});\n",
    "static": true,
    "longname": "/Users/woutercleymans/Webunit/SockTrader/src/tests/utils.spec.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 357,
    "kind": "test",
    "name": "describe74",
    "testId": 74,
    "memberof": "tests/utils.spec.ts",
    "testDepth": 0,
    "static": true,
    "longname": "tests/utils.spec.ts~describe74",
    "access": null,
    "description": "Strategy utilities",
    "lineNumber": 5
  },
  {
    "__docId__": 358,
    "kind": "test",
    "name": "it75",
    "testId": 75,
    "memberof": "tests/utils.spec.ts~describe74",
    "testDepth": 1,
    "static": true,
    "longname": "tests/utils.spec.ts~describe74.it75",
    "access": null,
    "description": "Should find a positive crossover",
    "lineNumber": 6
  },
  {
    "__docId__": 359,
    "kind": "test",
    "name": "it76",
    "testId": 76,
    "memberof": "tests/utils.spec.ts~describe74",
    "testDepth": 1,
    "static": true,
    "longname": "tests/utils.spec.ts~describe74.it76",
    "access": null,
    "description": "Should find a negative crossover",
    "lineNumber": 15
  }
]